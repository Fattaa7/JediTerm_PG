{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "tools_third-party-tools_git_Git-Commit.txt"}, "page_content": "Git Commit\nWhat files to commit\nIn general, you put under version control, whatever is a something that you created.\nYou do not put the result of a generator under version control.\nExample: In a Java project, you add all the source files, but not the class files \n(located typically in the 'bin' folder), because they are generated by Eclipse or \nthe Java compiler as a result of you sources. So if the sources are in version \ncontrol, you can recreate the class files immediately.\nThis is the general rule. There might be exceptions, e.g. if the generation takes \nlong time. Example FPGA compilation. Then you might add the generated result as well\nin GIT to save time.\nWhat to put into a single commit\nEach commit shall be for a single reason.\nEach commit is reviewed, hence each commit shall be understandable by reviewers.\nIf files source are generated by a tool or by copy and search-replace actions, then \nput those files directly into a commit. Do not mix with later edits.\nBecause the reviewer cannot know where to focus on. For them it is a great help if \nthose steps are in separated commits.\nCommit Messages\nThe GIT commit messages shall have line wrapping at 72 chars.\nWhen working with Gerrit the message must have one head line with max 72 chars, an \nemtpy line and the generated Change-Id line.\nOptionally more text can be added between head line and Change-Id, surrounded by a \nsingle empty line.\nHead line\nMore text. More text. More text. More text. More text.\nMore text. More text. More text. More text. More text.\nMore text. More text. More text.\nChange-Id: I01e940149ec4f6b5a7a4a0f97b5a9fac3437fca5", "type": "Document"}}