{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "test-scripting_java_java-libraries_best-practices_better-approaches-to-design-fusion-testing-libraries.txt"}, "page_content": "Better Approaches to Design Fusion Testing Libraries (Handling Multiple EXUS)\nDeveloping a fusion testing platform is complicated and requires special handling \nwhile designing Java testing libs.\"Working with multiple Exus\" is an important \ndesign factor to be considered within the fusion test environment.Generically \nspeaking, test cases are considered as sets of instructions to be executed by the \nEXU.Hence, EXU type should be explicitly identified within all test \ncases.Identifying your EXU to be TS, VD, FS, ..etc. is mandatory in test \ncases.Hereby, I would like to highlight 2 trivial approaches to avoid while \ndeclaring the EXU type in fusion test cases :Duplicate testing libs by the number of\nEXUs in project :Every duplicate will be specific to an EXU type.Normally in fusion \ntesting projects, we have at least 3 EXUs to work with! (Many instances of same \ncode).Modify all testing libs upon every run with the targeted EXU.Much rework \neffort.The optimum solution to this problem is to design your test cases to be \ngeneric / parameterized to handle any number / type of EXUs without the need for \nmodification or code duplicates.Please follow the following steps in your test libs \nto realize this approach :Use IExu instead of Exu (All Exus (ETS, EVD, EFS, ... ) \nextend the IExu)Use this :Instead of this :publicEFS exu;The Exu type is to be \nconfigured in runtime by the launcher used to run CTE.For example, in this CTE \nlauncher FUS_GEELY_FS11_64B_FS.cmd we can find the exu type is passed as an argument\n:-exu.type FSThe library constructor is then configured with the Exu type passed \n:publicManual_Can_Lib(IExu _exu) {if(_exuinstanceofEFS) {   exu = (EFS) _exu;   \nItf_ComHs = ((EFS)exu()).modTS().objComHs();  }elseif(_exuinstanceofETS) {   exu = \n(ETS) _exu;   Itf_ComHs = ((ETS)exu()).modTS().objComHs();  \n}elseif(_exuinstanceofEVV) {   exu = (EVV) _exu;   Itf_ComHs = \n((EVV)exu()).modTS().objComHs();  }}Invoke all needed APIs with respect to the \nparent interface (declared once at the library constructor) instead of duplicating \nspecific Exu instances :For example, if we need to send 10 Can messages, we should \nfirst declare the parent ComHs interface  :config.ItfComHs \nItf_ComHs;publicManual_Can_Lib(IExu _exu) {if(_exuinstanceofEFS) {   exu = (EFS) \n_exu;   Itf_ComHs = ((EFS)exu()).modTS().objComHs();  }}Then, invoke the APIs wrt \nthe declared interface :Itf_ComHs.objAVM_RxAppMsg_084().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_085().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...The old approach requires \nspecific Exu declaration with each API call (not recommended)\nDeveloping a fusion testing platform is complicated and requires special handling \nwhile designing Java testing libs.\nDeveloping a fusion testing platform is complicated and requires special handling \nwhile designing Java testing libs.\n\"Working with multiple Exus\" is an important design factor to be considered within \nthe fusion test environment.\n\"Working with multiple Exus\" is an important design factor to be considered within \nthe fusion test environment.\nGenerically speaking, test cases are considered as sets of instructions to be \nexecuted by the EXU.\nGenerically speaking, test cases are considered as sets of instructions to be \nexecuted by the EXU.\nHence, EXU type should be explicitly identified within all test cases.\nHence, EXU type should be explicitly identified within all test cases.\nIdentifying your EXU to be TS, VD, FS, ..etc. is mandatory in test cases.\nIdentifying your EXU to be TS, VD, FS, ..etc. is mandatory in test cases.\nHereby, I would like to highlight 2 trivial approaches to avoid while declaring the \nEXU type in fusion test cases :Duplicate testing libs by the number of EXUs in \nproject :Every duplicate will be specific to an EXU type.Normally in fusion testing \nprojects, we have at least 3 EXUs to work with! (Many instances of same code).Modify\nall testing libs upon every run with the targeted EXU.Much rework effort.\nHereby, I would like to highlight 2 trivial approaches to avoid while declaring the \nEXU type in fusion test cases :\nDuplicate testing libs by the number of EXUs in project :Every duplicate will be \nspecific to an EXU type.Normally in fusion testing projects, we have at least 3 EXUs\nto work with! (Many instances of same code).\nDuplicate testing libs by the number of EXUs in project :\nEvery duplicate will be specific to an EXU type.\nEvery duplicate will be specific to an EXU type.\nNormally in fusion testing projects, we have at least 3 EXUs to work with! (Many \ninstances of same code).\nNormally in fusion testing projects, we have at least 3 EXUs to work with! (Many \ninstances of same code).\nModify all testing libs upon every run with the targeted EXU.Much rework effort.\nModify all testing libs upon every run with the targeted EXU.\nMuch rework effort.\nMuch rework effort.\nThe optimum solution to this problem is to design your test cases to be generic / \nparameterized to handle any number / type of EXUs without the need for modification \nor code duplicates.\nThe optimum solution to this problem is to design your test cases to be generic / \nparameterized to handle any number / type of EXUs without the need for modification \nor code duplicates.\nPlease follow the following steps in your test libs to realize this approach :Use \nIExu instead of Exu (All Exus (ETS, EVD, EFS, ... ) extend the IExu)Use this \n:Instead of this :publicEFS exu;The Exu type is to be configured in runtime by the \nlauncher used to run CTE.For example, in this CTE launcher FUS_GEELY_FS11_64B_FS.cmd\nwe can find the exu type is passed as an argument :-exu.type FSThe library \nconstructor is then configured with the Exu type passed :publicManual_Can_Lib(IExu \n_exu) {if(_exuinstanceofEFS) {   exu = (EFS) _exu;   Itf_ComHs = \n((EFS)exu()).modTS().objComHs();  }elseif(_exuinstanceofETS) {   exu = (ETS) _exu;  \nItf_ComHs = ((ETS)exu()).modTS().objComHs();  }elseif(_exuinstanceofEVV) {   exu = \n(EVV) _exu;   Itf_ComHs = ((EVV)exu()).modTS().objComHs();  }}Invoke all needed APIs\nwith respect to the parent interface (declared once at the library constructor) \ninstead of duplicating specific Exu instances :For example, if we need to send 10 \nCan messages, we should first declare the parent ComHs interface  :config.ItfComHs \nItf_ComHs;publicManual_Can_Lib(IExu _exu) {if(_exuinstanceofEFS) {   exu = (EFS) \n_exu;   Itf_ComHs = ((EFS)exu()).modTS().objComHs();  }}Then, invoke the APIs wrt \nthe declared interface :Itf_ComHs.objAVM_RxAppMsg_084().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_085().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...The old approach requires \nspecific Exu declaration with each API call (not recommended)\nPlease follow the following steps in your test libs to realize this approach :\nUse IExu instead of Exu (All Exus (ETS, EVD, EFS, ... ) extend the IExu)Use this \n:Instead of this :publicEFS exu;The Exu type is to be configured in runtime by the \nlauncher used to run CTE.For example, in this CTE launcher FUS_GEELY_FS11_64B_FS.cmd\nwe can find the exu type is passed as an argument :-exu.type FSThe library \nconstructor is then configured with the Exu type passed :publicManual_Can_Lib(IExu \n_exu) {if(_exuinstanceofEFS) {   exu = (EFS) _exu;   Itf_ComHs = \n((EFS)exu()).modTS().objComHs();  }elseif(_exuinstanceofETS) {   exu = (ETS) _exu;  \nItf_ComHs = ((ETS)exu()).modTS().objComHs();  }elseif(_exuinstanceofEVV) {   exu = \n(EVV) _exu;   Itf_ComHs = ((EVV)exu()).modTS().objComHs();  }}\nUse IExu instead of Exu (All Exus (ETS, EVD, EFS, ... ) extend the IExu)\nUse this :\nUse this :\nInstead of this :publicEFS exu;\nInstead of this :\npublicEFS exu;\npublicEFS exu;\nThe Exu type is to be configured in runtime by the launcher used to run CTE.\nThe Exu type is to be configured in runtime by the launcher used to run CTE.\nFor example, in this CTE launcher FUS_GEELY_FS11_64B_FS.cmd we can find the exu type\nis passed as an argument :-exu.type FS\nFor example, in this CTE launcher FUS_GEELY_FS11_64B_FS.cmd we can find the exu type\nis passed as an argument :\n-exu.type FS\n-exu.type FS\nThe library constructor is then configured with the Exu type passed \n:publicManual_Can_Lib(IExu _exu) {if(_exuinstanceofEFS) {   exu = (EFS) _exu;   \nItf_ComHs = ((EFS)exu()).modTS().objComHs();  }elseif(_exuinstanceofETS) {   exu = \n(ETS) _exu;   Itf_ComHs = ((ETS)exu()).modTS().objComHs();  \n}elseif(_exuinstanceofEVV) {   exu = (EVV) _exu;   Itf_ComHs = \n((EVV)exu()).modTS().objComHs();  }}\nThe library constructor is then configured with the Exu type passed :\npublicManual_Can_Lib(IExu _exu) {if(_exuinstanceofEFS) {   exu = (EFS) _exu;   \nItf_ComHs = ((EFS)exu()).modTS().objComHs();  }elseif(_exuinstanceofETS) {   exu = \n(ETS) _exu;   Itf_ComHs = ((ETS)exu()).modTS().objComHs();  \n}elseif(_exuinstanceofEVV) {   exu = (EVV) _exu;   Itf_ComHs = \n((EVV)exu()).modTS().objComHs();  }}\npublicManual_Can_Lib(IExu _exu) {if(_exuinstanceofEFS) {   exu = (EFS) _exu;   \nItf_ComHs = ((EFS)exu()).modTS().objComHs();  }elseif(_exuinstanceofETS) {   exu = \n(ETS) _exu;   Itf_ComHs = ((ETS)exu()).modTS().objComHs();  \n}elseif(_exuinstanceofEVV) {   exu = (EVV) _exu;   Itf_ComHs = \n((EVV)exu()).modTS().objComHs();  }}\nInvoke all needed APIs with respect to the parent interface (declared once at the \nlibrary constructor) instead of duplicating specific Exu instances :For example, if \nwe need to send 10 Can messages, we should first declare the parent ComHs interface \n:config.ItfComHs Itf_ComHs;publicManual_Can_Lib(IExu _exu) {if(_exuinstanceofEFS) { \n  exu = (EFS) _exu;   Itf_ComHs = ((EFS)exu()).modTS().objComHs();  }}Then, invoke \nthe APIs wrt the declared interface \n:Itf_ComHs.objAVM_RxAppMsg_084().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_085().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...\nInvoke all needed APIs with respect to the parent interface (declared once at the \nlibrary constructor) instead of duplicating specific Exu instances :\nFor example, if we need to send 10 Can messages, we should first declare the parent \nComHs interface  :config.ItfComHs Itf_ComHs;publicManual_Can_Lib(IExu _exu) \n{if(_exuinstanceofEFS) {   exu = (EFS) _exu;   Itf_ComHs = \n((EFS)exu()).modTS().objComHs();  }}\nFor example, if we need to send 10 Can messages, we should first declare the parent \nComHs interface  :\nconfig.ItfComHs Itf_ComHs;publicManual_Can_Lib(IExu _exu) {if(_exuinstanceofEFS) {  \nexu = (EFS) _exu;   Itf_ComHs = ((EFS)exu()).modTS().objComHs();  }}\nconfig.ItfComHs Itf_ComHs;publicManual_Can_Lib(IExu _exu) {if(_exuinstanceofEFS) {  \nexu = (EFS) _exu;   Itf_ComHs = ((EFS)exu()).modTS().objComHs();  }}\nThen, invoke the APIs wrt the declared interface \n:Itf_ComHs.objAVM_RxAppMsg_084().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_085().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...\nThen, invoke the APIs wrt the declared interface :\nItf_ComHs.objAVM_RxAppMsg_084().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_085().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...\nItf_ComHs.objAVM_RxAppMsg_084().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_085().afcSendPerTimer(10); \nItf_ComHs.objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...\nThe old approach requires specific Exu declaration with each API call (not \nrecommended)\nThe old approach requires specific Exu declaration with each API call (not \nrecommended)\npublicIExu exu;\npublicIExu exu;\npublicIExu exu;\npublicIExu exu;\npublicIExu exu;\npublicIExu exu;\npublicIExu exu;\nexu().modTS().objComHs().objAVM_RxAppMsg_084().afcSendPerTimer(10); \nexu().modTS().objComHs().objAVM_RxAppMsg_085().afcSendPerTimer(10); \nexu().modTS().objComHs().objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...\nexu().modTS().objComHs().objAVM_RxAppMsg_084().afcSendPerTimer(10); \nexu().modTS().objComHs().objAVM_RxAppMsg_085().afcSendPerTimer(10); \nexu().modTS().objComHs().objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...\nexu().modTS().objComHs().objAVM_RxAppMsg_084().afcSendPerTimer(10); \nexu().modTS().objComHs().objAVM_RxAppMsg_085().afcSendPerTimer(10); \nexu().modTS().objComHs().objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...\nexu().modTS().objComHs().objAVM_RxAppMsg_084().afcSendPerTimer(10); \nexu().modTS().objComHs().objAVM_RxAppMsg_085().afcSendPerTimer(10); \nexu().modTS().objComHs().objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...\nexu().modTS().objComHs().objAVM_RxAppMsg_084().afcSendPerTimer(10); \nexu().modTS().objComHs().objAVM_RxAppMsg_085().afcSendPerTimer(10); \nexu().modTS().objComHs().objAVM_RxAppMsg_0E0().afcSendPerTimer(10); ...", "type": "Document"}}