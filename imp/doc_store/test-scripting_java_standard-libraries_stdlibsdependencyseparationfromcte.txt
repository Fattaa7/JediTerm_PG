{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "test-scripting_java_standard-libraries_stdlibsdependencyseparationfromcte.txt"}, "page_content": "Stdlibs Dependency Separation from CTE\nPost date: Mar 22, 2021 3:31:25 PM\nAs Stdlibs are part of 1_Castle, it requires to export whole CTE to generate a new \njar file for every change in the Stdlibs. this leads to a headache to the project \nowner and the std developer to reflect any change in a project (exporting the CTE, \nupload them manually until an official FW release.... etc. ).Starting from \ncommitf89f4aed366d2b1c5c18a2e883150baaf493c60a, Stdlibs are independent from CTE \nanymore, a new task was added to build.gradle inside \n1_Castleupdate_exported_stdlib.The output of this task is a stdlib.jar file - inside\nthis path \"\\1_Castle\\exported.tools\\castle.testenv.stdlib\" - reflecting any change \nin the Stdlibs. Hence there is no need any more to export whole CTE as before.A \ncheck is done to compare between the firmware core version of the project and the \ncore version of the output stdlib.jar to avoid any incompatibility in between. If \nthe check fails, the CTE will throw an assert to inform the user the two \nincompatible version (Stdlibs and the base firmware).The Stdlib developer can write \nhis own implementation for the newly added functioncheckLibParametersto prevent a \nsingle incompatible lib to be loaded in the CTE project.\nAs Stdlibs are part of 1_Castle, it requires to export whole CTE to generate a new \njar file for every change in the Stdlibs. this leads to a headache to the project \nowner and the std developer to reflect any change in a project (exporting the CTE, \nupload them manually until an official FW release.... etc. ).\nAs Stdlibs are part of 1_Castle, it requires to export whole CTE to generate a new \njar file for every change in the Stdlibs. this leads to a headache to the project \nowner and the std developer to reflect any change in a project (exporting the CTE, \nupload them manually until an official FW release.... etc. ).\nStarting from commitf89f4aed366d2b1c5c18a2e883150baaf493c60a, Stdlibs are \nindependent from CTE anymore, a new task was added to build.gradle inside \n1_Castleupdate_exported_stdlib.\nStarting from commitf89f4aed366d2b1c5c18a2e883150baaf493c60a, Stdlibs are \nindependent from CTE anymore, a new task was added to build.gradle inside \n1_Castleupdate_exported_stdlib.\nThe output of this task is a stdlib.jar file - inside this path \n\"\\1_Castle\\exported.tools\\castle.testenv.stdlib\" - reflecting any change in the \nStdlibs. Hence there is no need any more to export whole CTE as before.\nThe output of this task is a stdlib.jar file - inside this path \n\"\\1_Castle\\exported.tools\\castle.testenv.stdlib\" - reflecting any change in the \nStdlibs. Hence there is no need any more to export whole CTE as before.\nA check is done to compare between the firmware core version of the project and the \ncore version of the output stdlib.jar to avoid any incompatibility in between. If \nthe check fails, the CTE will throw an assert to inform the user the two \nincompatible version (Stdlibs and the base firmware).\nA check is done to compare between the firmware core version of the project and the \ncore version of the output stdlib.jar to avoid any incompatibility in between. If \nthe check fails, the CTE will throw an assert to inform the user the two \nincompatible version (Stdlibs and the base firmware).\nThe Stdlib developer can write his own implementation for the newly added \nfunctioncheckLibParametersto prevent a single incompatible lib to be loaded in the \nCTE project.\nThe Stdlib developer can write his own implementation for the newly added \nfunctioncheckLibParametersto prevent a single incompatible lib to be loaded in the \nCTE project.\n- Developer Guide for this new change:\nStarting from the commit mentioned above, use the latest .classpath template and \nbuild.gradle template (1_Castle\\castle.project.initializer\\templates\\Cte) for user \nprojects, it shall has three changes, adding a new gradle plugin to use the official\nstdlib.jar released on nexus, a deprecation of the dependency of the old jar file \n(castle.testenv.stdlib_1.0.0.released) and adding the new dependency of the new \nexported stdlib.jar.\nStarting from the commit mentioned above, use the latest .classpath template and \nbuild.gradle template (1_Castle\\castle.project.initializer\\templates\\Cte) for user \nprojects, it shall has three changes, adding a new gradle plugin to use the official\nstdlib.jar released on nexus, a deprecation of the dependency of the old jar file \n(castle.testenv.stdlib_1.0.0.released) and adding the new dependency of the new \nexported stdlib.jar.\nAdd exported.stdlib folder to .gitignore file in the user project to avoid \ncommitting stdlib.jar.If the Stdlib developer needs to add a hot fix for the project\nwithout waiting an official CTE release, he can runupdate_exported_stdlibtask in \nbuild.gradle in 1_Castle after any java change in the stdlibs then manually copy the\nnew generated stdlib.jar in the user project inside folder exported.stdlib, comment \ngradle plugin and manually force commit his new stdlib.jar (instead of getting the \nofficial one released on nexus) as below then push it to the project repo..\nAdd exported.stdlib folder to .gitignore file in the user project to avoid \ncommitting stdlib.jar.\nAdd exported.stdlib folder to .gitignore file in the user project to avoid \ncommitting stdlib.jar.\nIf the Stdlib developer needs to add a hot fix for the project without waiting an \nofficial CTE release, he can runupdate_exported_stdlibtask in build.gradle in \n1_Castle after any java change in the stdlibs then manually copy the new generated \nstdlib.jar in the user project inside folder exported.stdlib, comment gradle plugin \nand manually force commit his new stdlib.jar (instead of getting the official one \nreleased on nexus) as below then push it to the project repo..\nIf the Stdlib developer needs to add a hot fix for the project without waiting an \nofficial CTE release, he can runupdate_exported_stdlibtask in build.gradle in \n1_Castle after any java change in the stdlibs then manually copy the new generated \nstdlib.jar in the user project inside folder exported.stdlib, comment gradle plugin \nand manually force commit his new stdlib.jar (instead of getting the official one \nreleased on nexus) as below then push it to the project repo..\nLaunch the project, if the core versions are compatible, the project will be loaded \nnormally, if not an assert will be pop up as below showing the two incompatible \nversion between the stdlib.jar and the base firmware.\nLaunch the project, if the core versions are compatible, the project will be loaded \nnormally, if not an assert will be pop up as below showing the two incompatible \nversion between the stdlib.jar and the base firmware.\nLaunch the project, if the core versions are compatible, the project will be loaded \nnormally, if not an assert will be pop up as below showing the two incompatible \nversion between the stdlib.jar and the base firmware.\nThe Stdlib developer can override the default implementation oif the newly add \nfunctioncheckLibParametersin any stdlib with any kind of information he needs to \ninform the user project, shown below an example of overriding the function in CanFd \nstandard library.\nThe Stdlib developer can override the default implementation oif the newly add \nfunctioncheckLibParametersin any stdlib with any kind of information he needs to \ninform the user project, shown below an example of overriding the function in CanFd \nstandard library.\nThe Stdlib developer can override the default implementation oif the newly add \nfunctioncheckLibParametersin any stdlib with any kind of information he needs to \ninform the user project, shown below an example of overriding the function in CanFd \nstandard library.", "type": "Document"}}