{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "test-scripting_hardware-apis_product-lines-fc_tutorials_fc-interrupt-based-reset-request.txt"}, "page_content": "[ FC ] Interrupt Based Reset Request\nCastle simulates MobileEye EyeQ camera in the testing setup , When an erroneous \nbehavior happens , - such as the ECU receiving a wrong CRC header from EyeQ - , the \nECU shall reset the EyeQ through pulling Down the Reset Pin\nCastle simulates MobileEye EyeQ camera in the testing setup , When an erroneous \nbehavior happens , - such as the ECU receiving a wrong CRC header from EyeQ - , the \nECU shall reset the EyeQ through pulling Down the Reset Pin\nwhen EyeQ resets , it reboots and reset all communication - such as sequence number \n- and then re-establish the communication again with the ECU\nwhen EyeQ resets , it reboots and reset all communication - such as sequence number \n- and then re-establish the communication again with the ECU\nthis is a typical fault injection scenario , when the tester inject a fault - such \nas an invalid CRC header - then waits for the ECU to Reset EyeQ by pulling Down the \nReset Pin\nthis is a typical fault injection scenario , when the tester inject a fault - such \nas an invalid CRC header - then waits for the ECU to Reset EyeQ by pulling Down the \nReset Pin\nfailing to catch the Reset  signal on-time can cause many problems in some scenarios\n,includes:> failing to Simulate the real EyeQ behavior\nfailing to catch the Reset  signal on-time can cause many problems in some scenarios\n,includes:> failing to Simulate the real EyeQ behavior\n> logging Extra DTC's count because castle continues to send corrupted frames even \nafter the reset request , which dosen't happen in the real scenario\n> Failing to re-establish the SPI communication between Castle(simulating EyeQ) and \nthe ECU after many fault injection , hence failing to resume the test case\nFirmware Implementation\nthe feature is implemented in the firmware as a GPIO interrupt , the reset Pin is \nConnected to a Gpio core , when the level of Pin's voltage changes , an interrupt is\ntriggered , which lead to the calling of the interrupt handler ,if this interrupt is\nenabled,the interrupt handler Triggers the event \n:objMIPC().evtIP_Reset_Requested(),prints a message to the CTE log , and deactavie \nthe SPI Lines based on the user choice.\nimpl commit Id :0e57f0aa904c6b6fedd1d41b93e6424b5ad8b224\nHow To Use ?\n1- First Connect the reset Pin from the ECU to Pin 23 of the FC PIP's PinHeader as \nillustrated below\n2- Then Enable this feature by calling the following api :\nobjMIPC().afcEnableIpResetInterrupt(boolDeaActivateSpiOnReset );\nthe boolean flag \"DeaActivateSpiOnReset \"control wether castle should automatically \ndeactivate SPI lines when reset signal is received or notNever Enable this interrupt\nif you don't connect the Reset Pin , because this will expose the Pin to floating \nvoltage , causing false interrupts to be triggerd\n3- after enabling the feature , any reset request will trigger an Event which you \ncan wait for whenever you expect a reset to happen , for example :\nexu.pauseUntilEvent(exu.modTS().objMIPC().evtIP_Reset_Requested(), );\nthe reset will also print a message on the CTE Log\nNotes\nthere is an old implementation mentionedhere\nthis old implementation won't be stable because it uses the pooling approach instead\nof the interrupt approach , since the width of the reset pulse is within \nmicroseconds , it's very easy to miss the reset pulse", "type": "Document"}}