{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "test-scripting_hardware-apis_product-lines-cam_tutorials_storing-the-captured-image-to-ecu-within-the-test-case-hil-mode.txt"}, "page_content": "Storing the captured image to ECU within the test case (HIL Mode)\nWe added three classes to the Volvo PAC project directory \n(SVS_Volvo_PAC\\SVS_Volvo_PAC_CteDev\\prj\\src\\prj) to store the captured image within \nthe             test case :\nStoreFrameHIl\nStoreFrameHIl\nCameraDriverEventListener\nCameraDriverEventListener\nStoringNames\nStoringNames\nNow, \"StoreFrame\" class is dedicated to storing captured frames in the direct mode, \nand  \"StoreFrameHIl\"  class is dedicated to storing captured frames in the HIL mode \nto solve the issue of switching to direct mode for storing frames.\nNow, \"StoreFrame\" class is dedicated to storing captured frames in the direct mode, \nand  \"StoreFrameHIl\"  class is dedicated to storing captured frames in the HIL mode \nto solve the issue of switching to direct mode for storing frames.\n\"StoreFrameHil\" is executed the same way like \"StoreFrame\", just pass the file name \nin CTE, or if you intend to use it within a test group, you can instantiate it with \nthe targeted file names.\n\"StoreFrameHil\" is executed the same way like \"StoreFrame\", just pass the file name \nin CTE, or if you intend to use it within a test group, you can instantiate it with \nthe targeted file names.\n\"StoringNames\" class is used for holding the names of saved frames to solve an issue\nof file naming that will be discussed in details in this article.\n\"StoringNames\" class is used for holding the names of saved frames to solve an issue\nof file naming that will be discussed in details in this article.\n\"CameraDriverEventListener\" class is used for filtering the targeted message by \ncomparing the message name, and type.\n\"CameraDriverEventListener\" class is used for filtering the targeted message by \ncomparing the message name, and type.\nStoring single captured frame in the HIL mode takes around 10 seconds to be \naccomplished.\nStoring single captured frame in the HIL mode takes around 10 seconds to be \naccomplished.\nThe big picture\nThe test is to run in three phases:Phase 1: The HIL Test java coderuns on PCAny \ncommand that starts with \"exu.ModTS().....\" triggers a copy from PC to CASTLE PIM \nthrough Ethernet interface. The data contained in this transfer contains a test step\nwith time stamp.Phase 2: HIL Testruns on CASTLE PIMFrom the last phase, the PIM has \na Queue of test steps, each has its time stamp.These steps are executed in the PIM. \nEach step in its corresponding time stamp.Steps containing \ncamdrv.afcStoreFromCapFrameBuffer command will generate a message holding line \ndataPhase 3: Event listenerruns on PCUpon each message received, the listener is \nexecuted on PC.\nThe test is to run in three phases:Phase 1: The HIL Test java coderuns on PCAny \ncommand that starts with \"exu.ModTS().....\" triggers a copy from PC to CASTLE PIM \nthrough Ethernet interface. The data contained in this transfer contains a test step\nwith time stamp.Phase 2: HIL Testruns on CASTLE PIMFrom the last phase, the PIM has \na Queue of test steps, each has its time stamp.These steps are executed in the PIM. \nEach step in its corresponding time stamp.Steps containing \ncamdrv.afcStoreFromCapFrameBuffer command will generate a message holding line \ndataPhase 3: Event listenerruns on PCUpon each message received, the listener is \nexecuted on PC.\nThe test is to run in three phases:\nPhase 1: The HIL Test java coderuns on PCAny command that starts with \n\"exu.ModTS().....\" triggers a copy from PC to CASTLE PIM through Ethernet interface.\nThe data contained in this transfer contains a test step with time stamp.\nPhase 1: The HIL Test java coderuns on PC\nAny command that starts with \"exu.ModTS().....\" triggers a copy from PC to CASTLE \nPIM through Ethernet interface. The data contained in this transfer contains a test \nstep with time stamp.\nAny command that starts with \"exu.ModTS().....\" triggers a copy from PC to CASTLE \nPIM through Ethernet interface. The data contained in this transfer contains a test \nstep with time stamp.\nPhase 2: HIL Testruns on CASTLE PIMFrom the last phase, the PIM has a Queue of test \nsteps, each has its time stamp.\nPhase 2: HIL Testruns on CASTLE PIM\nFrom the last phase, the PIM has a Queue of test steps, each has its time stamp.\nFrom the last phase, the PIM has a Queue of test steps, each has its time stamp.\nThese steps are executed in the PIM. Each step in its corresponding time stamp.\nThese steps are executed in the PIM. Each step in its corresponding time stamp.\nSteps containing camdrv.afcStoreFromCapFrameBuffer command will generate a message \nholding line data\nSteps containing camdrv.afcStoreFromCapFrameBuffer command will generate a message \nholding line data\nPhase 3: Event listenerruns on PCUpon each message received, the listener is \nexecuted on PC.\nPhase 3: Event listenerruns on PC\nUpon each message received, the listener is executed on PC.\nUpon each message received, the listener is executed on PC.\nFrame storing step by step :\nFrame storing process starts within the test case inphase 1\nFrame storing process starts within the test case inphase 1\nThe process uses the command  camdrv.afcStoreFromCapFrameBuffer to bring the line \ndata (3*768 bytes of RGB data) from the camera frame buffer with a specific line \noffset.\nThe process uses the command  camdrv.afcStoreFromCapFrameBuffer to bring the line \ndata (3*768 bytes of RGB data) from the camera frame buffer with a specific line \noffset.\nThe process needs 1024 iteration to cover all lines in the frame (frame resolution \nin Volvo PAC = 1024*768)\nThe process needs 1024 iteration to cover all lines in the frame (frame resolution \nin Volvo PAC = 1024*768)\nint offset;\nint rowBytes =3*768;\nfor(offset=0;offset<=1023;offset++)  {\ncamdrv.afcStoreFromCapFrameBuffer(cfb,1023-offset, rowBytes); } //Grab the RGB data \n(3*768 bytes) in one step\nDefining the required row bytes to be 3*678 bytes caused the firmware queue to \ncrash.\nDefining the required row bytes to be 3*678 bytes caused the firmware queue to \ncrash.\nDue to the throughput of the file storing process is less than it of the received \nmessages, leading to congesting the queue with large data messages that are \ncomparable to the firmware messages queue size.\nDue to the throughput of the file storing process is less than it of the received \nmessages, leading to congesting the queue with large data messages that are \ncomparable to the firmware messages queue size.\nA proposed solution was to decrease the size of data a message holds to a value that\nis much less than the queue size :\nA proposed solution was to decrease the size of data a message holds to a value that\nis much less than the queue size :\nint line_offset,RGB_offset;\nint rowBytes = 768;\nfor(line_offset=0;line_offset<=1023;){camdrv.afcStoreFromCapFrameBuffer(cfb, \n(((1023-line_offset)*3*rowBytes)+(RGB_offset*768)), rowBytes);\nRGB_offset++;\nif(RGB_offset==3) {RGB_offset=0;line_offset++;}//grab the RGB data on three steps, \nonly when the RGB data is                           //grabbed, you can increase the \nline offset\n}\nEven if queue congestion happened, it would not lead to queue overflow, as the \nmessage size is now much less than the queue size, giving the file storing process \nenough time to store the smaller messages.\nEven if queue congestion happened, it would not lead to queue overflow, as the \nmessage size is now much less than the queue size, giving the file storing process \nenough time to store the smaller messages.\nNow, the process reachedPhase 2where all the triggered steps are being executed in \nthe PIM, each step in its corresponding time stamp.After the \ncamdrv.afcStoreFromCapFrameBuffer  command is executed, a message is generated to \ngrab the rowBytes data from the camera frame buffer.\nNow, the process reachedPhase 2where all the triggered steps are being executed in \nthe PIM, each step in its corresponding time stamp.\nAfter the camdrv.afcStoreFromCapFrameBuffer  command is executed, a message is \ngenerated to grab the rowBytes data from the camera frame buffer.\nAfter the camdrv.afcStoreFromCapFrameBuffer  command is executed, a message is \ngenerated to grab the rowBytes data from the camera frame buffer.\nIn \"CteSetup\" class, we added a listener to the generated message :\nIn \"CteSetup\" class, we added a listener to the generated message :\npublic static Consumer<IModuleMessage> listener;\nThe class CameraDriverEventListener uses the listener variable for filtering the \ntargeted message inPhase 3by comparing the message name, and type :\nThe class CameraDriverEventListener uses the listener variable for filtering the \ntargeted message inPhase 3by comparing the message name, and type :\nThe class CameraDriverEventListener uses the listener variable for filtering the \ntargeted message inPhase 3by comparing the message name, and type :\npublic class CameraDriverEventListener implements ICteEventListener {\n@Override\npublic void cteEvent(CteEventType type, String name, Object param) {\nStoreFrameHIL storeHil = new StoreFrameHIL();//Create new instance of StoreFrameHIL \nclass to call the listener method once   we get //the targeted message\nConsumer<IModuleMessage> listener = CteSetup.listener;\nif( type == CteEventType.Message && name.equals(\"msgStorePart\")){//filtering the \nrequired message\nIModuleMessage msg = (IModuleMessage)param;\nstoreHil.storeFrameListener(msg);//passing the message to the listener to extract \ndata from it, and append it to the writing file.\n}\nAdded also the following methods in \"CteSetup\" class to add, or remove the listener \n:The listener is added when we start our store process, and removed when all frames \nare stored.\nAdded also the following methods in \"CteSetup\" class to add, or remove the listener \n:\nAdded also the following methods in \"CteSetup\" class to add, or remove the listener \n:\nThe listener is added when we start our store process, and removed when all frames \nare stored.\nThe listener is added when we start our store process, and removed when all frames \nare stored.\npublic void addStoreFrameListener( Consumer<IModuleMessage> l ) {listener = l;}     \n                                              public void removeStoreFrameListener()\n{listener = null;  }\nAdding the listener is done by passing a (pointer to the listener method) to the \n(listener variable in \"CteSetup\") :\nAdding the listener is done by passing a (pointer to the listener method) to the \n(listener variable in \"CteSetup\") :\ncteSetup.addStoreFrameListener( this::storeFrameListener);//storeFrameListener is \nthe listener method\nOnce the message is received in CTE on PC, the test process entersPhase 3where the \nlistener is supposed to invoke the method it points to (storeFrameListener)\nOnce the message is received in CTE on PC, the test process entersPhase 3where the \nlistener is supposed to invoke the method it points to (storeFrameListener)\npublic void storeFrameListener( IModuleMessage msg ) {\nString _data = new String();\nHexString part;\n_data = msg.getValue(\"Data\").getFormattedValue();//extract the data from the message\npart = HexString.parseRawArray(_data);\nif(f==null){ //check if the file is created or not\nstore_file =\"Captured_buffer_\"+FileName+\".bmp\";//FileName is passed by the class \nconstructor\ntry {f = new BufferedOutputStream(new FileOutputStream(store_file));} catch \n(FileNotFoundException e1)             {e1.printStackTrace();}\ntry {f.write(headerBMP54, 0, 54);} catch (IOException e) {e.printStackTrace();}}\nif(offset <= 1023) try {\n//until the maximum offset is reached, we append the received data to the created \nfile\nf.write(part.toArray());\n} catch (IOException e) {e.printStackTrace();}\nif (offset ==1023) {\n//After reaching the maximum offset in the file, we close it, make the file variable\n= null to create a new file\n//when the next message comes, and clear the offset variable to start from offset \nzero in the next frame.\ntry {f.close(); f=null; offset= 0;}\ncatch (IOException e) {e.printStackTrace();}\n} else {offset++;}}\nObviously, before enteringPhase 3, we hadPhase 1done where the HIL Test java code is\nfinished.\nObviously, before enteringPhase 3, we hadPhase 1done where the HIL Test java code is\nfinished.\n\"CaptureStore\" is the high level API called in the test case inPhase 1to capture, \nand store the frame in the HIL mode.\n\"CaptureStore\" is the high level API called in the test case inPhase 1to capture, \nand store the frame in the HIL mode.\nThe API creates multiple instances of \"StoreFramHil\", each corresponding to a \nspecific test case.Each instance has its own storing file name passed by the \nconstructor to its instance variable FileName\nThe API creates multiple instances of \"StoreFramHil\", each corresponding to a \nspecific test case.\nEach instance has its own storing file name passed by the constructor to its \ninstance variable FileName\nEach instance has its own storing file name passed by the constructor to its \ninstance variable FileName\npublic void CaptureStore(String ID)\n{\nItfCamerasDriver.EnmCaptureFrameBuffer b_CapFrameBufferID;\nb_CapFrameBufferID  = \nconfig.ItfCamerasDriver.EnmCaptureFrameBuffer.CAP_FrameBuffer_0 ;\nStoreFrameHIL MyStore = new StoreFrameHIL(b_CapFrameBufferID, \n\"Captured_buffer_\"+ID+\".bmp\");\nexu.pause(500);\nexu.exec(MyStore);\n}\nThe following code demonstrates a simulation of how three consecutive test cases use\nthe capturestore API inPhase 1to capture 3 frames, and save them with the passed \nnames :\nThe following code demonstrates a simulation of how three consecutive test cases use\nthe capturestore API inPhase 1to capture 3 frames, and save them with the passed \nnames :\nThe following code demonstrates a simulation of how three consecutive test cases use\nthe capturestore API inPhase 1to capture 3 frames, and save them with the passed \nnames :\nCaptureStore(\"PAS_Inner_Outer_rear_1\");\nexu.pause(10000);\nCaptureStore(\"PAS_Inner_Outer_rear_2\");\nexu.pause(10000);\nCaptureStore(\"PAS_Inner_Outer_rear_3\");\nexu.pause(10000);\nWhen \"CaptureStore\"is used within a test group or even used standalone in step \nrunner, it is invoked 3 three times :Two times in Dry Run modeOne time in Execution \nmode\nWhen \"CaptureStore\"is used within a test group or even used standalone in step \nrunner, it is invoked 3 three times :Two times in Dry Run modeOne time in Execution \nmode\nWhen \"CaptureStore\"is used within a test group or even used standalone in step \nrunner, it is invoked 3 three times :\nTwo times in Dry Run mode\nTwo times in Dry Run mode\nOne time in Execution mode\nOne time in Execution mode\nNow, only the last created instance inPhase 1(holding the file name : \n\"PAS_Inner_Outer_rear_3\")is taken into account in thePhase 3.\nNow, only the last created instance inPhase 1(holding the file name : \n\"PAS_Inner_Outer_rear_3\")is taken into account in thePhase 3.\nAll files created by the listener method inPhase 3will hold the same name \n(\"PAS_Inner_Outer_rear_3\").\nAll files created by the listener method inPhase 3will hold the same name \n(\"PAS_Inner_Outer_rear_3\").\nA proposed solution was to append the time stamp of the test step to the file name \nto avoid the naming issue, but it has some drawbacks :The readability of the stored \nframes names will decreaseThe testers will consume much time matching stored frames \nwith corresponding test casesAutomated frame compare cannot be used anymore\nA proposed solution was to append the time stamp of the test step to the file name \nto avoid the naming issue, but it has some drawbacks :\nThe readability of the stored frames names will decrease\nThe readability of the stored frames names will decrease\nThe testers will consume much time matching stored frames with corresponding test \ncases\nThe testers will consume much time matching stored frames with corresponding test \ncases\nAutomated frame compare cannot be used anymore\nAutomated frame compare cannot be used anymore\nThis issue was fixed by creating a class \"StoringNames\" to hold the names in a \nqueue.\nThis issue was fixed by creating a class \"StoringNames\" to hold the names in a \nqueue.\nEvery time the listener method is called in Phase 3, it dequeues the file name from \n\"StoringNames\" class queue.\nEvery time the listener method is called in Phase 3, it dequeues the file name from \n\"StoringNames\" class queue.\nstore_file =\"Captured_buffer_\"+StoringNames.getID()+\".bmp\";", "type": "Document"}}