{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "tools_third-party-tools_git_gitwhatsadetachedheadingit.txt"}, "page_content": "[Git] What's a \"detached HEAD\" in Git?\nPost date: Jun 12, 2017 10:39:14 AM\nWhen you checkout a specific Git Commit instead of a branch, your HEAD pointer will \nnot belong to any branch, this is called a detached HEAD.\nThe problem with a detached HEAD\nThe HEAD pointer in Git determines your current working revision (and thereby the \nfiles that are placed in your project's working directory). Normally, when checking \nout a proper branch name, Git automatically moves the HEAD pointer along when you \ncreate a new commit. You are automatically on the newest commit of the chosen \nbranch. When you instead choose to check out a commit hash, Git won't do this for \nyou. The consequence is that when you make changes and commit them, these changes do\nNOT belong to any branch. This means they can easily get lost once you check out a \ndifferent revision or branch: not being recorded in the context of a branch, you \nlack the possibility to access that state easily (unless you have a brilliant memory\nand can remember the commit hash of that new commit...).\nMore to Read: (Source)\nWhat's a \"detached HEAD\" in Git?\nIt might very well be that you'll never come across this \"mysterious\" state in your \nGit career. However, if you do one day, you'd probably like to know what a \"detached\nHEAD\" is - and how you might have arrived at that state.\nUnderstanding how \"checkout\" works\nWith the \"git checkout\" command, you determine which revision of your project you \nwant to work on. Git then places all of that revision's files in your working copy \nfolder.\nNormally, you use abranch nameto communicate with \"git checkout\":\n$ git checkout development\nHowever, youcanalso provide theSHA1 hashof a specific commit instead:\n$ git checkout 56a4e5c08 Note: checking out '56a4e5c08'.  You are in 'detached HEAD'\nstate...\nThis exact state - when a specificcommitis checked out instead of abranch- is what's\ncalled a \"detached HEAD\".\nThe problem with a detached HEAD\nThe HEAD pointer in Git determines your current working revision (and thereby the \nfiles that are placed in your project's working directory). Normally, when checking \nout a proper branch name, Git automatically moves the HEAD pointer along when you \ncreate a new commit. You are automatically on the newest commit of the chosen \nbranch.\nWhen you instead choose to check out acommit hash, Git won't do this for you. The \nconsequence is that when you make changes and commit them, thesechanges do NOT \nbelong to any branch.\nThis means they can easily get lost once you check out a different revision or \nbranch: not being recorded in the context of a branch, you lack the possibility to \naccess that state easily (unless you have a brilliant memory and can remember the \ncommit hash of that new commit...).\nWhen a detached HEAD shows up\nThere are a handful of situations where detached HEAD states are common:\nSubmodulesare indeed checked out at specific commits instead of branches.Rebaseworks\nby creating atemporarydetached HEAD state while it runs.\nSubmodulesare indeed checked out at specific commits instead of branches.\nSubmodulesare indeed checked out at specific commits instead of branches.\nRebaseworks by creating atemporarydetached HEAD state while it runs.\nRebaseworks by creating atemporarydetached HEAD state while it runs.\nWhere a detached HEAD should not show up\nAdditionally, another situation might spring to mind: what about going back in time \nto try out an older version of your project? For example in the context of a bug, \nyou want to see how things worked in an older revision.\nThis is a perfectly valid and common use case. However, you don't have to maneuver \nyourself into a detached HEAD state to deal with it. Instead, remember how simple \nand cheap the whole concept of branching is in Git: you can simply create a \n(temporary) branch and delete it once you're done.\n$ git checkout -b test-branch 56a4e5c08  ...do your thing...  $ git checkout master \n$ git branch -d test-branch", "type": "Document"}}