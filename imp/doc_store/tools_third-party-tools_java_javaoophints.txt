{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "tools_third-party-tools_java_javaoophints.txt"}, "page_content": "Java OOP Hints\nPost date: Mar 6, 2016 12:23:28 PM\nAbout Reference Counter and Garbage Collector\nEach object contains reference counter, contains the number of references which \npoint to it.\nGarbage collector passes by all objects reference counters from time to time, and \nremoves any  not referenced objects.\nYou may give a hint to grabage collector to start working using System.gc()\nAbout Eclipse IDE\nTo rename a field: right click on the field > refactor, so all the occurrences will \nbe renamed\nAuto format (Indent, spaces, ..etc): Right ht Click > Source > Format (ctrl+shift+f)\nAutomatically create setters and getters for an attribute: Right Click > refactor > \ncreate setters and getters\nBasics\n- Each Java program shall have one and only one \u201cpublic static void main\u201d as an \nentry point for the whole program\n- package  mypack              // put the classes in this file in the package mypack\n- import  package1.*         // import all classes of the package package1 to my \nfile\n- import  package1.class1                // import class1 of the package package1 to\nmy file\nOverriding Vs Overloading\n- Overloading is defining more that one method with the same name (different \narguments)\n- Overriding:\nYou can define the same method with the same signature once in the super-class, and \nonce in the subclass, each with different implementation.\nIn the subclass use \u201c@Override\u201d\nInheritance\nAny class is a subclass of a super-class called \u201cObject\u201d.\nAny class is a subclass of a super-class called \u201cObject\u201d.\nIf I have \u201cVehicle\u201d super-class attributes: \u201cDirection\u201d and \u201cspeed\u201d. And method \n\u201cMoveForward()\u201d \u201cgetSpeed\u201d, Sub class \u201cTruck\u201d with attribute \u201cLoad\u201d methods: \n\u201c@override MoveForward()\u201d and \u201cgetLoad\u201d, \u201csetLoad\u201dVehicle car = new \ncar();Car.moveForward() // calls moveForward of the superclassVehicle otherCar = new\nTruck();otherCar.moveForward()// calls moveForward of the truck \nsubclassotherCar.setLoad() // however the object of the class truck, and contains \nthe method setload, but this method cannot be called from car referenceInstead, you \ncan access this method by casting the reference \u201cCar\u201d to \u201cTruck\u201d as follows:Truck \notherTruck = (Truck) otherCar;otherTruck.setLoad();Any subclass constructor calls \nthe superclass constructor\nIf I have \u201cVehicle\u201d super-class attributes: \u201cDirection\u201d and \u201cspeed\u201d. And method \n\u201cMoveForward()\u201d \u201cgetSpeed\u201d, Sub class \u201cTruck\u201d with attribute \u201cLoad\u201d methods: \n\u201c@override MoveForward()\u201d and \u201cgetLoad\u201d, \u201csetLoad\u201d\nVehicle car = new car();\nVehicle car = new car();\nCar.moveForward() // calls moveForward of the superclass\nCar.moveForward() // calls moveForward of the superclass\nVehicle otherCar = new Truck();\nVehicle otherCar = new Truck();\notherCar.moveForward()// calls moveForward of the truck subclass\notherCar.moveForward()// calls moveForward of the truck subclass\notherCar.setLoad() // however the object of the class truck, and contains the method\nsetload, but this method cannot be called from car reference\notherCar.setLoad() // however the object of the class truck, and contains the method\nsetload, but this method cannot be called from car reference\nInstead, you can access this method by casting the reference \u201cCar\u201d to \u201cTruck\u201d as \nfollows:\nInstead, you can access this method by casting the reference \u201cCar\u201d to \u201cTruck\u201d as \nfollows:\nTruck otherTruck = (Truck) otherCar;\nTruck otherTruck = (Truck) otherCar;\notherTruck.setLoad();\notherTruck.setLoad();\nAny subclass constructor calls the superclass constructor\nAny subclass constructor calls the superclass constructor\nif (objName instanceof ClassName) // return true if objName references an object of \ntype ClassName\nif (objName instanceof ClassName) // return true if objName references an object of \ntype ClassName\nVehicle otherCar = new Truck();new Truck() is a constructor method thatcreates an \nobject of class Truck in the memoryreturn a reference to this objectotherCar is a \nreference points to the created truck object.It can only access methods defined in \nclass Vehicle. (in case of overriding the method implementation of the subclass is \nused, because this is the one defined in the actual object created in the memory)To \naccess the fields defined in Truck -> cast this otherCar reference into reference to\nTruck.\nVehicle otherCar = new Truck();\nnew Truck() is a constructor method thatcreates an object of class Truck in the \nmemoryreturn a reference to this object\nnew Truck() is a constructor method that\ncreates an object of class Truck in the memory\ncreates an object of class Truck in the memory\nreturn a reference to this object\nreturn a reference to this object\notherCar is a reference points to the created truck object.\notherCar is a reference points to the created truck object.\nIt can only access methods defined in class Vehicle. (in case of overriding the \nmethod implementation of the subclass is used, because this is the one defined in \nthe actual object created in the memory)\nIt can only access methods defined in class Vehicle. (in case of overriding the \nmethod implementation of the subclass is used, because this is the one defined in \nthe actual object created in the memory)\nTo access the fields defined in Truck -> cast this otherCar reference into reference\nto Truck.\nTo access the fields defined in Truck -> cast this otherCar reference into reference\nto Truck.\nAbstract Class\nabstract class contain at least one abstract method.\nabstract class contain at least one abstract method.\nabstract method prototype is declared in the abstract class\nabstract method prototype is declared in the abstract class\nabstract method must be implemented in each subclass. (use @Override)\nabstract method must be implemented in each subclass. (use @Override)\nInterface\ninterface contains only unimplemented methods.\ninterface contains only unimplemented methods.\nClasses that implements this interface must implement all the functions declared in \nthe interface (use \u201c@Override\u201d)\nClasses that implements this interface must implement all the functions declared in \nthe interface (use \u201c@Override\u201d)\nLinkedList Vs ArrayList\nArrayList: all elements in the same region in the memory \u00e0 faster in looping for the\narray elements\nLinkedList: elements are not in the same memory region \u00e0 faster if you will add and \nremove elements frequently\nStrings concatenation\nUse \u201cStringBuffer.append\u201d instead of \u201c+\u201d while concatenation. \u00e0 much better in time \nand memory utilization.\n\u201cWe\u201d + \u201c Want\u201d + \u201c Freedom\u201dWrite \u201cWe\u201d in memoryWrite \u201cWant\u201d memoryGather we and want\nand put them in new place in memory \u201cWe Want\u201d \u2026etc\n\u201cWe\u201d + \u201c Want\u201d + \u201c Freedom\u201d\nWrite \u201cWe\u201d in memory\nWrite \u201cWe\u201d in memory\nWrite \u201cWant\u201d memory\nWrite \u201cWant\u201d memory\nGather we and want and put them in new place in memory \u201cWe Want\u201d \u2026etc\nGather we and want and put them in new place in memory \u201cWe Want\u201d \u2026etc", "type": "Document"}}