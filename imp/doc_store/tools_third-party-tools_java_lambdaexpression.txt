{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "tools_third-party-tools_java_lambdaexpression.txt"}, "page_content": "Lambda Expression\nPost date: Mar 6, 2016 12:23:44 PM\nOne issue with anonymous classes is that if the implementation of your anonymous \nclass is very simple, such as an interface that contains only one method,\nthen the syntax of anonymous classes may seem unwieldy and unclear. In these cases, \nyou're usually trying to pass functionality as an argument to another method,\nsuch as what action should be taken when someone clicks a button. Lambda expressions\n(introduced since java 8) enable you to do this, to treat functionality as method \nargument, or code as data.\nAn Example and An Old approach\nSuppose we want to create an interface called \"adder\" that has only one method \n\"add\". It takes 2 integers and return their sum.\nWe want to implement this interface using 2 ways: the normal \"+\" operator and \nMath.addExact. Thus a classic java implementation can be like that:\ninterfaceAdder{Integeradd(int a, int b);}classClassicAdderimplementsAdder{    \n@OverridepublicIntegeradd(int a, int b) {returna + b;    \n}}classMathAdderimplementsAdder{    @OverridepublicIntegeradd(int a, int b) \n{returnMath.addExact(a,b);    }}classTestAdder {publicstaticvoid main(String[] \nargs){        Adder adder1 =newClassicAdder();  Adder adder2 =newMathAdder();     \nint a = 5; int b = 2;System.out.println(\"Result of adder 1 : \" + \nadder1.add(a,b));System.out.println(\"Result of adder 2 : \" + adder2.add(a,b));    }}\nOutput\nResult of adder 1 : 7\nResult of adder 2 : 7\nYou can notice that too much code is used for just mini-functions.\nBelow you can find the beauty and simplicity of lambda expression that we can write \nthe different implementations of Adder in just 2 lines.\n@FunctionalInterfaceinterfaceAdder{Integeradd(int a, int b);}classTestAdder \n{publicstaticvoid main(String[] args){        Adder adder1 = (a, b) -> a + b; \n//lambda1        Adder adder2 = (a, b) ->Math.addExact(a,b); //lambda2            \nint a = 5; int b = 2;System.out.println(\"Result of adder 1 : \" + \nadder1.add(a,b));System.out.println(\"Result of adder 2 : \" + adder2.add(a,b));    }}\nOutput\nResult of adder 1 : 7\nResult of adder 2 : 7\nWhat is a Functional Interface ?\nAn informative annotation type \"@FunctionalInterface\" defined by the Java Language \nSpecification.\nConceptually, a functional interface has exactly one abstract method. If it has more\nthan one method the java compiler will generate an error.\nNote that if the annotation is not written although the interface consists of only \none method. Java will consider it functional interface as well.\nHow does a lambda expression work and what does it return ?\nIt takes the parameters and the body of the method and then returns the functional \ninterface of the type used in assignment.\nAbove in //lambda1 and //lambda2, it returns an interface of type Adder.\nWhat is the Syntax of a lambda expression?\n(Parameters)         ->     (Body)\n(a, b) -> (a + b)\n(a, b) -> (Math.addExact(a, b))\n1-Parameters:A comma-separated list of formal parameters enclosed in parentheses. \nThese are the parameters of the overridden method of the functional interface.\nParameters could be with or without types. Thus, we can also pass them like that : \n(int a, int b) -> a + b.\n2-Array Token:\"->\"\n3-Body :A single expression or a statement Block.\nThis is the body of the method of the functional interface as in above: (a + b) or \n(Math.addExact(a, b))\nIf it is a single expression then it is considered directly as a return statement.\nSo you can always enclose statements in braces ({}), hence an equivalent code for \nexample above is:\nAdder p = (a, b) -> {\nreturna + b;\n};\nCommon Applications of Lambda Expressions:\nUsually, when we need to iterate over lists, we exert some redundant effort in \nwriting loops and if conditions.\nSuppose in a Castle 5 project, we want make Rx processing for all RX Flexray Frames.\nHere is the classic and modern way to do this:\nList<RootInterface> frames = exu.modTS().objComFr().objFrames().getChildObjects(); \nfor(RootInterface frame: frames){if(frameinstanceofItf_ComFrameFlexrayRx){        \nItf_ComFrameFlexrayRx rxFrame = (Itf_ComFrameFlexrayRx) frame;        \nrxFrame.afcEnableRxProcessing(EnmEnableProcessingEnum.Full);    }}// Although, using\nlambda expressions along with stream filters, we can do something like this:  \nexu.modTS().objComFr().objFrames().getChildObjects() .stream() .filter(p -> p \ninstanceof Itf_ComFrameFlexrayRx) .map(p -> (Itf_ComFrameFlexrayRx)p) .forEach(p -> \np.afcEnableRxProcessing(EnmEnableProcessingEnum.Full));\n1-stream():Converts any List (List<T>) to a Stream (Stream<T>) which is a sequence \nof elements supporting sequential and parallel aggregate operations.\n2-filter(Predicate<? super T> predicate):It filters the input stream and returns \nanother output stream based on the predicate result.\nWhat is a Predicate (Predicate<T>) ?\nFunctional interface that represents a (boolean-valued function) of one argument.\nIts abstract method signature is \"boolean test(T t)\". The type <T> will be inherited\nfrom the type of stream elements.\nIn our example it will be considered as Predicate<RootInterface>, and the \nimplementation of its method \"boolean test(RootInterface p)\":\n{return (p instanceof Itf_ComFrameFlexrayRx);}\n3-map(Function<? super T, ? extends R> mapper):It returns a stream consisting of the\nresults of applying the given function to the elements of the input stream.\nWhat is a Function (Function<T,R>) ?\nFunctional interface representing a function that accepts one argument and produces \na result.\nIts abstract method signature is \"R apply(T t)\".\nThe return type <R> will be inherited from the return type of passed function.\nThe type <T> will be inherited from the type of stream elements.\nIn our example it will be considered as \nFunction<RootInterface,Itf_ComFrameFlexrayRx>, and the implementation of its method \n\"Itf_ComFrameFlexrayRx (RootInterface p)\": {return (Itf_ComFrameFlexrayRx)p;}\n4-forEach(Consumer<? super T> action):Performs an action for each element of the \ninput stream.\nWhat is a Consumer (Consumer<T>) ?\nFunctional interface representing an operation that accepts a single input argument \nand returns no result.\nIts abstract method signature is \"void accept(T t)\". The type <T> will be inherited \nfrom the type of stream elements.\nIn our example it will be considered as Consumer<Itf_ComFrameFlexrayRx>, and the \nimplementation of its method \"void accept(Itf_ComFrameFlexrayRx p)\" : \n{p.afcEnableRxProcessing(EnmEnableProcessingEnum.Full);}\nYou can find all functional interfaces provided by \"java.util.function\" package in \nthislink.", "type": "Document"}}