{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "product-lines_camera-systems_dvs-induction.txt"}, "page_content": "DVS Induction\nMotivation\nThe purpose of this article is to document the process of capturing/storing frames \nfrom the moment a frame is captured till it is stored on the desktop, which would \nbe      a good training for a newcomer to the DVS firmware team to boost his start \nand avoid one to one coaching.\nWe will start our journey with the rear view camera systems [RVC]\nOverview\nThe rear view camera is connected directly to the vehicle head unit [simulated by \ncastle in our case] via high speed serial data cable supporting one of the 3 types \nof       digital connectors :\nHigh-Speed Data (HSD) Rosenberger connectorHSD cables have 2 twisted pairs inside a \nshield holding Vcc, Gnd, D+, D-\nHigh-Speed Data (HSD) Rosenberger connector\nHSD cables have 2 twisted pairs inside a shield holding Vcc, Gnd, D+, D-\nHSD cables have 2 twisted pairs inside a shield holding Vcc, Gnd, D+, D-\nFAKRA connector\nFAKRA connector\nSupporting coaxial cables that have an inner conductor surrounded by a tubular \ninsulating layer, surrounded by a tubular conducting shield\nSupporting coaxial cables that have an inner conductor surrounded by a tubular \ninsulating layer, surrounded by a tubular conducting shield\nJAE connector\nJAE connector\nThe RVC produces a video stream with dynamic overlays which present an onscreen \nvisualization of the vehicle steering trajectory.\nThe infotainment head unit (IHU) and the RVC communicate over a back channel \ncommunication protocol (I2C) with the LVDS cable :\nSerializer:Host controller has no direct communication with the serializer, as the \nHost controller is a slave, while the IHU is the master of the LVDS line. However \nserializer is used to transmit the LVDS serialized video data + the communication \ndata from IHU and Host controller, across to the IHU side.\nSerializer:Host controller has no direct communication with the serializer, as the \nHost controller is a slave, while the IHU is the master of the LVDS line. However \nserializer is used to transmit the LVDS serialized video data + the communication \ndata from IHU and Host controller, across to the IHU side.\nISP:Host controller is the master of the ISP, using I2C as a communication \ninterface. Host commands ISP to do specific functions, eg: activate specific LUT, \nactivate overlay, change overlay.\nISP:Host controller is the master of the ISP, using I2C as a communication \ninterface. Host commands ISP to do specific functions, eg: activate specific LUT, \nactivate overlay, change overlay.\nImager:Is an image sensor that outputs 10 bits video data + Hsync and Vsync.\nImager:Is an image sensor that outputs 10 bits video data + Hsync and Vsync.\nSPI Flash:Holds 4MB of data. Has all the sensor configurations, view LUT \nconfigurations, and all steering overlay bitmaps, command sequences to enable each \nspecific overlay. Multiple vehicles information is included in this SPI flash image.\nSPI Flash:Holds 4MB of data. Has all the sensor configurations, view LUT \nconfigurations, and all steering overlay bitmaps, command sequences to enable each \nspecific overlay. Multiple vehicles information is included in this SPI flash image.\nWe have two types of bit sequences that can be flashed to the SPI Flash block inside\nthe ecu : Valeo and Delphi bit sequences\nWe have two types of bit sequences that can be flashed to the SPI Flash block inside\nthe ecu : Valeo and Delphi bit sequences\nThe difference between them is that every one results in an ISP bit order that is \nthe reverse of the other.\nThe difference between them is that every one results in an ISP bit order that is \nthe reverse of the other.\nHost MicroController:is the Master of the ISP and the Imager, it ensures the \ncomplete system(serializer, ISP, Imager, SPI flash) is powered up via the voltage \ninterfaces, and communicates with the IHU via LVDS I2C communication through the \nserializer to receive information.The Host also communicates with the ISP through \nI2C to enable specific view LUTs depending on the request from either diagnostics or\nthe vehicle type. Host also sends specific commands to ISP to enable/disable \noverlays, either static or dynamic.\nHost MicroController:is the Master of the ISP and the Imager, it ensures the \ncomplete system(serializer, ISP, Imager, SPI flash) is powered up via the voltage \ninterfaces, and communicates with the IHU via LVDS I2C communication through the \nserializer to receive information.The Host also communicates with the ISP through \nI2C to enable specific view LUTs depending on the request from either diagnostics or\nthe vehicle type. Host also sends specific commands to ISP to enable/disable \noverlays, either static or dynamic.\nInfotainment Head Unit:is used to manage different ECUs that require to display \ninformation on its LCD screen. It commands the RVCM via the LVDS I2C interface.\nInfotainment Head Unit:is used to manage different ECUs that require to display \ninformation on its LCD screen. It commands the RVCM via the LVDS I2C interface.\nIn our DVS projects we have two serializer / deserializer  pairs : Maxim and TI, \nboth form a complete digital video serial link.\nThe serializer located in the camera ecu scrambles and encodes the input data from \nthe image sensor processor and sends the coded signal through the serial link.\nThe serializer located in the camera ecu scrambles and encodes the input data from \nthe image sensor processor and sends the coded signal through the serial link.\nThe deserializer located in the project PIP recovers the embedded serial clock and \nthen samples, decodes, and descrambles before outputting the data.\nThe deserializer located in the project PIP recovers the embedded serial clock and \nthen samples, decodes, and descrambles before outputting the data.\nThe process of encoding / decoding data is product specific and has to be done with \nboth sides (ser./des.) from the same manufacturer.\nDVS projects working with Maxim family : Parkman, Volvo\nDVS projects working with Maxim family : Parkman, Volvo\nDVS projects working with TI family : GM, Chrysler\nDVS projects working with TI family : GM, Chrysler\nSoon, all RVC projects will migrate to the generic RVC PIP V2\nSoon, all RVC projects will migrate to the generic RVC PIP V2\nCASTLE Side\nWe have built a genericRVC PIPwhich has both flavors of derserializers to serve any \nRVC project.\nThisfoldercontains all schematics of video project PIP`s we are developing, you can \nrefer to it for a more informative look.\nAfter the serial frame data is transmitted through the LVDS channel, it enters the \ndeserializer chip to convert it to parallel data.\nThe following figure is to emphasize you understood well the format of the \ndeserialized data :\nThe deserialized data lines are : n-bit pixel data lines, HSync, VSync, DE, Pclk.\nThe deserialized data lines are : n-bit pixel data lines, HSync, VSync, DE, Pclk.\nEach pixel 8-bit data is transmitted on the edge of the pixel colck till the whole \nline is formed, then HSync signal is raised (If it's active high, depends on \nrequirements).\nEach pixel 8-bit data is transmitted on the edge of the pixel colck till the whole \nline is formed, then HSync signal is raised (If it's active high, depends on \nrequirements).\nOnce the whole frame transmission is completed, VSync signal is raised (If it's \nactive high, depends on requirements).\nOnce the whole frame transmission is completed, VSync signal is raised (If it's \nactive high, depends on requirements).\nNote that the change of the Hsync & the Vsync signals level are delayed for short \ntimes & these times represent the front porch & the back porsh, for more information\ncheck this \nwikihttps://sites.google.com/a/valeo.com/castle-project/castle-5/platform-developmen\nt/new-modules-in-castle-5/quad-camera-module\nNote that the change of the Hsync & the Vsync signals level are delayed for short \ntimes & these times represent the front porch & the back porsh, for more information\ncheck this \nwikihttps://sites.google.com/a/valeo.com/castle-project/castle-5/platform-developmen\nt/new-modules-in-castle-5/quad-camera-module\nThe parallel data will be mapped to one of the input banks of the FPGA to be \nassigned to the video in module (v_vid_in)\nThe parallel data will be mapped to one of the input banks of the FPGA to be \nassigned to the video in module (v_vid_in)\nFor more details about the higher entity configuration parameters of the video in \nmodule, you can refer to the project .mhs file in the hardware directory (HW \nfolder).You can configure the hardware core it self from 4_FirmwareBase/FPGA/pcores.\nFor more details about the higher entity configuration parameters of the video in \nmodule, you can refer to the project .mhs file in the hardware directory (HW \nfolder).\nYou can configure the hardware core it self from 4_FirmwareBase/FPGA/pcores.\nYou can configure the hardware core it self from 4_FirmwareBase/FPGA/pcores.\nThe video in module formats parallel video data into a stream of signals compliant \nto AXI4-Stream protocol.The VDMA module (Video Direct Memory Access) connected to \nthe AXI4 bus provides fast streams between the AXI4-Stream and the off-chip DDR3 \nMemory.A DDR controller (axi_bram_ctrl_0) is connected to the DDR memory \n(axi_bram_ctrl_0_bram_block) with physical lines to retrieve its data.Now, it is the\nfirmware turn to grab frame data from the VDMACameras.c FW module contains all \nrequired APIs to capture and store the frameA golbal array is declared to store \nframe data : uint8 capBuffer[CAP_FB_COUNT][VID_CH_BUFF_LEN_CAP];All buffer addresses\nare set inside WriteCfg.FrameStoreStartAddr for transfer in the DMA \nengine.XAxiVdma_DmaSetBufferAddr(InstancePtr, \nXAXIVDMA_WRITE,WriteCfg.FrameStoreStartAddr);Then, all frame data will be retrieved \nfrom the capBuffer to be stored on the desktop :A make message holding capBuffer \ndata is fired from FW : CamerasDriver_MakeMsg_StorePartThen, a listener is \nimplemented in java app layer to get frame data and store it.\nThe video in module formats parallel video data into a stream of signals compliant \nto AXI4-Stream protocol.\nThe VDMA module (Video Direct Memory Access) connected to the AXI4 bus provides fast\nstreams between the AXI4-Stream and the off-chip DDR3 Memory.\nThe VDMA module (Video Direct Memory Access) connected to the AXI4 bus provides fast\nstreams between the AXI4-Stream and the off-chip DDR3 Memory.\nA DDR controller (axi_bram_ctrl_0) is connected to the DDR memory \n(axi_bram_ctrl_0_bram_block) with physical lines to retrieve its data.\nA DDR controller (axi_bram_ctrl_0) is connected to the DDR memory \n(axi_bram_ctrl_0_bram_block) with physical lines to retrieve its data.\nNow, it is the firmware turn to grab frame data from the VDMA\nNow, it is the firmware turn to grab frame data from the VDMA\nCameras.c FW module contains all required APIs to capture and store the frame\nCameras.c FW module contains all required APIs to capture and store the frame\nA golbal array is declared to store frame data : uint8 \ncapBuffer[CAP_FB_COUNT][VID_CH_BUFF_LEN_CAP];\nA golbal array is declared to store frame data : uint8 \ncapBuffer[CAP_FB_COUNT][VID_CH_BUFF_LEN_CAP];\nAll buffer addresses are set inside WriteCfg.FrameStoreStartAddr for transfer in the\nDMA engine.\nAll buffer addresses are set inside WriteCfg.FrameStoreStartAddr for transfer in the\nDMA engine.\nXAxiVdma_DmaSetBufferAddr(InstancePtr, XAXIVDMA_WRITE,WriteCfg.FrameStoreStartAddr);\nXAxiVdma_DmaSetBufferAddr(InstancePtr, XAXIVDMA_WRITE,WriteCfg.FrameStoreStartAddr);\nThen, all frame data will be retrieved from the capBuffer to be stored on the \ndesktop :\nThen, all frame data will be retrieved from the capBuffer to be stored on the \ndesktop :\nA make message holding capBuffer data is fired from FW : \nCamerasDriver_MakeMsg_StorePart\nA make message holding capBuffer data is fired from FW : \nCamerasDriver_MakeMsg_StorePart\nThen, a listener is implemented in java app layer to get frame data and store it.\nThen, a listener is implemented in java app layer to get frame data and store it.", "type": "Document"}}