{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "test-scripting_hardware-apis_networking-all-physical-links_checkifframeisreceivedwhencheckingasignalvalue.txt"}, "page_content": "Check if Frame is received when checking a Signal Value.\nPost date: Jan 29, 2019 7:30:10 PM\nChecking on a value of a Signal can sometimes be tricky under some use cases such \nas:\nChecking if the Signal value is 0 at the start of the test.0 is the default value \nthat is set for any Signal when first powering up the test bench.Checking if the \nSignal value is equal to some specific value.That value could have already been \nstored in the buffers, but was not updated as the frame was never received again.\nChecking if the Signal value is 0 at the start of the test.\nChecking if the Signal value is 0 at the start of the test.\n0 is the default value that is set for any Signal when first powering up the test \nbench.\n0 is the default value that is set for any Signal when first powering up the test \nbench.\nChecking if the Signal value is equal to some specific value.\nChecking if the Signal value is equal to some specific value.\nThat value could have already been stored in the buffers, but was not updated as the\nframe was never received again.\nThat value could have already been stored in the buffers, but was not updated as the\nframe was never received again.\nAn extra check can be performed to ensure that the value being tested on, is the \nvalue being transmitted by the Software Under Test.\nThis practice is currently used in DAS-RAD Project: MB79 P2.\nThe idea is to check that the frame was transmitted, by telling the test bench to \nupdate an internal counter (related to the Signal) each time the signal is updated.\nThe implementation that serves this purpose is:afcUpdateCounterCheck(int _MinError, \nint _MinWarn, int _MaxWarn, int _MaxError).\nThe implementation is part of the class:Itf_Signal.\nBelow is an example used when checking that a Signal value is equal to a specific \nvalue:\n// Reset the internal counter to 0.\n// Make sure to enable the Rx Processing of the Frame\nsigObject.afcUpdateCounterReset();\n// Enable logging of the signal value on each update event.\n// The argument is set to false, to inform the test bench that the counter is to be \nupdated whether the value of the Signal changes or not.\n// If set to true, then the counter is updated only when the Signal value changes.\nsigObject.afcLoggingOnUpdateEnable(false);\n// Pause for some time,this should be equal to at the very least one cycle time of \nthe frame containing the Signal being checked.\nexu().pause(PAUSE_AFTER_LOGGING_UPDATE_ENABLE);\nsigObject.afcEqualsCheck(signalValue);\n// Disable the update of the counter.\nsigObject.afcLoggingOnUpdateDisable();\n// Check the counter value is between 1 and 2147483647 (2^31 - 1)\nsigObject.afcUpdateCounterCheck(1, 1, Integer.MAX_VALUE, Integer.MAX_VALUE);\nIn case the Frame was never transmitted, the failed test step would look like this:", "type": "Document"}}