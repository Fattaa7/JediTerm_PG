{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "product-lines_camera-systems_video_in-ip-core-architecture.txt"}, "page_content": "Video_in IP Core Architecture\nIn thisarticle, we have built an overview on the all building blocks embedded to \nrealize the capture feature. Now, we will dive deeply to explore the architecture of\nan important building block in the capture path (Video_in HW core).\nVideo_in main objective is to:Consume pixel data provided by the deserializer (Des. \nprovides one (or half) pixel at a time).Accumulate a pixel after another to form a \ncomplete image line.Stream the frame line to the VDMA on the AXIS bus.Such \nobjectives are realized by the following block diagram:\nVideo_in main objective is to:\nConsume pixel data provided by the deserializer (Des. provides one (or half) pixel \nat a time).\nConsume pixel data provided by the deserializer (Des. provides one (or half) pixel \nat a time).\nAccumulate a pixel after another to form a complete image line.\nAccumulate a pixel after another to form a complete image line.\nStream the frame line to the VDMA on the AXIS bus.\nStream the frame line to the VDMA on the AXIS bus.\nSuch objectives are realized by the following block diagram:\nSuch objectives are realized by the following block diagram:\nNow, we will discuss the function of every building block in detail:\nNow, we will discuss the function of every building block in detail:\nNow, we will discuss the function of every building block in detail:\nvid_in_axi4s_verThe top level entity of the video handling process.Forms complete \npixel data:Deserializer could send the whole pixel data aligned with Pclk line (at \nevery clock tick of Pclk, complete pixel data is transmitted)Or send half pixel data\naligned with Pclkx2 (at every clock tick of Pclkx2, half pixel data is \ntransmitted)Either way, vid_in_axi4s_ver is supposed to form total pixel data.Notice\nthat this entity consumes Pclk and Pclkx2 and provides only Pclk.Forming 24-bit data\nout of 2 consecutive 8-bits leaves constant 8-bit portion shared between adjacent \npixels. And this is the mechanism of the YUV color map.AXIS_tready signal is \nprovided by VDMA. It indicates the readiness of VDMA to receive data from the \nVideo_in core.\nvid_in_axi4s_ver\nThe top level entity of the video handling process.Forms complete pixel \ndata:Deserializer could send the whole pixel data aligned with Pclk line (at every \nclock tick of Pclk, complete pixel data is transmitted)Or send half pixel data \naligned with Pclkx2 (at every clock tick of Pclkx2, half pixel data is \ntransmitted)Either way, vid_in_axi4s_ver is supposed to form total pixel data.Notice\nthat this entity consumes Pclk and Pclkx2 and provides only Pclk.Forming 24-bit data\nout of 2 consecutive 8-bits leaves constant 8-bit portion shared between adjacent \npixels. And this is the mechanism of the YUV color map.AXIS_tready signal is \nprovided by VDMA. It indicates the readiness of VDMA to receive data from the \nVideo_in core.\nThe top level entity of the video handling process.\nThe top level entity of the video handling process.\nForms complete pixel data:Deserializer could send the whole pixel data aligned with \nPclk line (at every clock tick of Pclk, complete pixel data is transmitted)Or send \nhalf pixel data aligned with Pclkx2 (at every clock tick of Pclkx2, half pixel data \nis transmitted)Either way, vid_in_axi4s_ver is supposed to form total pixel \ndata.Notice that this entity consumes Pclk and Pclkx2 and provides only Pclk.Forming\n24-bit data out of 2 consecutive 8-bits leaves constant 8-bit portion shared between\nadjacent pixels. And this is the mechanism of the YUV color map.AXIS_tready signal \nis provided by VDMA. It indicates the readiness of VDMA to receive data from the \nVideo_in core.\nForms complete pixel data:\nDeserializer could send the whole pixel data aligned with Pclk line (at every clock \ntick of Pclk, complete pixel data is transmitted)\nDeserializer could send the whole pixel data aligned with Pclk line (at every clock \ntick of Pclk, complete pixel data is transmitted)\nOr send half pixel data aligned with Pclkx2 (at every clock tick of Pclkx2, half \npixel data is transmitted)\nOr send half pixel data aligned with Pclkx2 (at every clock tick of Pclkx2, half \npixel data is transmitted)\nEither way, vid_in_axi4s_ver is supposed to form total pixel data.\nEither way, vid_in_axi4s_ver is supposed to form total pixel data.\nNotice that this entity consumes Pclk and Pclkx2 and provides only Pclk.\nNotice that this entity consumes Pclk and Pclkx2 and provides only Pclk.\nForming 24-bit data out of 2 consecutive 8-bits leaves constant 8-bit portion shared\nbetween adjacent pixels. And this is the mechanism of the YUV color map.\nForming 24-bit data out of 2 consecutive 8-bits leaves constant 8-bit portion shared\nbetween adjacent pixels. And this is the mechanism of the YUV color map.\nAXIS_tready signal is provided by VDMA. It indicates the readiness of VDMA to \nreceive data from the Video_in core.\nAXIS_tready signal is provided by VDMA. It indicates the readiness of VDMA to \nreceive data from the Video_in core.\nvid_in_axi4s_topThis is the common ring entity that consumes an un-formatted pixel \ndata and direct it to the formatter entity to be formatted.After obtaining a \nformatted pixel, vid_in_axi4s_top is to direct such data to the coupler to be \nwritten in FIFO.Provides all necessary R/W signals to the coupler to drive the \nFIFO.Notice the different clock domains handled by vid_in_axi4s_top:FIFO write \ndomain:Writing formatted pixel data to the coupler synced with Pclk as FIFO Write \nClock.FIFO read domain:Reading formatted pixel data from the coupler using ACLK \n(AXIS Clock) as the read clock..\nvid_in_axi4s_top\nThis is the common ring entity that consumes an un-formatted pixel data and direct \nit to the formatter entity to be formatted.After obtaining a formatted pixel, \nvid_in_axi4s_top is to direct such data to the coupler to be written in \nFIFO.Provides all necessary R/W signals to the coupler to drive the FIFO.Notice the \ndifferent clock domains handled by vid_in_axi4s_top:FIFO write domain:Writing \nformatted pixel data to the coupler synced with Pclk as FIFO Write Clock.FIFO read \ndomain:Reading formatted pixel data from the coupler using ACLK (AXIS Clock) as the \nread clock..\nThis is the common ring entity that consumes an un-formatted pixel data and direct \nit to the formatter entity to be formatted.\nThis is the common ring entity that consumes an un-formatted pixel data and direct \nit to the formatter entity to be formatted.\nAfter obtaining a formatted pixel, vid_in_axi4s_top is to direct such data to the \ncoupler to be written in FIFO.\nAfter obtaining a formatted pixel, vid_in_axi4s_top is to direct such data to the \ncoupler to be written in FIFO.\nProvides all necessary R/W signals to the coupler to drive the FIFO.\nProvides all necessary R/W signals to the coupler to drive the FIFO.\nNotice the different clock domains handled by vid_in_axi4s_top:FIFO write \ndomain:Writing formatted pixel data to the coupler synced with Pclk as FIFO Write \nClock.FIFO read domain:Reading formatted pixel data from the coupler using ACLK \n(AXIS Clock) as the read clock..\nNotice the different clock domains handled by vid_in_axi4s_top:\nFIFO write domain:Writing formatted pixel data to the coupler synced with Pclk as \nFIFO Write Clock.\nFIFO write domain:\nWriting formatted pixel data to the coupler synced with Pclk as FIFO Write Clock.\nWriting formatted pixel data to the coupler synced with Pclk as FIFO Write Clock.\nFIFO read domain:Reading formatted pixel data from the coupler using ACLK (AXIS \nClock) as the read clock..\nFIFO read domain:\nReading formatted pixel data from the coupler using ACLK (AXIS Clock) as the read \nclock..\nReading formatted pixel data from the coupler using ACLK (AXIS Clock) as the read \nclock..\nvid_in_axi4s_formatterFormats input pixel data to mark it`s location in the \nframe.Inserts a prefix 2-bit identifier word to the 24-bit pixel data.\nvid_in_axi4s_formatter\nFormats input pixel data to mark it`s location in the frame.Inserts a prefix 2-bit \nidentifier word to the 24-bit pixel data.\nFormats input pixel data to mark it`s location in the frame.\nFormats input pixel data to mark it`s location in the frame.\nInserts a prefix 2-bit identifier word to the 24-bit pixel data.\nInserts a prefix 2-bit identifier word to the 24-bit pixel data.\nThe 2-bit identifier is simply the SOF (Start of Frame) and EOL (End of Line) \nmarkers to identify pixel location in the frame.The formatter entity mainly provides\nthe 26-bit word formatted pixel data and the FIFO_wr_en signal.FIFO_wr_en signal is \nsimply the DE (data enable) signal coming from the deserializer.\nThe 2-bit identifier is simply the SOF (Start of Frame) and EOL (End of Line) \nmarkers to identify pixel location in the frame.The formatter entity mainly provides\nthe 26-bit word formatted pixel data and the FIFO_wr_en signal.FIFO_wr_en signal is \nsimply the DE (data enable) signal coming from the deserializer.\nThe 2-bit identifier is simply the SOF (Start of Frame) and EOL (End of Line) \nmarkers to identify pixel location in the frame.\nThe 2-bit identifier is simply the SOF (Start of Frame) and EOL (End of Line) \nmarkers to identify pixel location in the frame.\nThe formatter entity mainly provides the 26-bit word formatted pixel data and the \nFIFO_wr_en signal.\nThe formatter entity mainly provides the 26-bit word formatted pixel data and the \nFIFO_wr_en signal.\nFIFO_wr_en signal is simply the DE (data enable) signal coming from the \ndeserializer.\nFIFO_wr_en signal is simply the DE (data enable) signal coming from the \ndeserializer.\nvid_in_axi4s_couplerProvides a unified interface to communicate with the FIFO.The \nonly way to write / read a word to / from FIFO is done through the coupler \ninterface.\nvid_in_axi4s_coupler\nProvides a unified interface to communicate with the FIFO.The only way to write / \nread a word to / from FIFO is done through the coupler interface.\nProvides a unified interface to communicate with the FIFO.\nProvides a unified interface to communicate with the FIFO.\nThe only way to write / read a word to / from FIFO is done through the coupler \ninterface.\nThe only way to write / read a word to / from FIFO is done through the coupler \ninterface.\nAsynch_FIFOWhy use a FIFO anyway ?Handling the Clock Domain Crossing in an efficient\nway.We have two clock domains as explained previously:Pixel write clock domain -> \nsynced with / controlled by the pixel clock signal coming from the \ndeserializer.Pixel read clock domain ->  synced with / controlled by the AXIS Aclk \nsignal (Constant 100 Mhz) to read data and feed to VDMA.No matter how fast / slow is\nthe Pclk, VDMA can read Pixel data safely from the FIFO independently.\nAsynch_FIFO\nWhy use a FIFO anyway ?Handling the Clock Domain Crossing in an efficient way.We \nhave two clock domains as explained previously:Pixel write clock domain -> synced \nwith / controlled by the pixel clock signal coming from the deserializer.Pixel read \nclock domain ->  synced with / controlled by the AXIS Aclk signal (Constant 100 Mhz)\nto read data and feed to VDMA.No matter how fast / slow is the Pclk, VDMA can read \nPixel data safely from the FIFO independently.\nWhy use a FIFO anyway ?Handling the Clock Domain Crossing in an efficient way.We \nhave two clock domains as explained previously:Pixel write clock domain -> synced \nwith / controlled by the pixel clock signal coming from the deserializer.Pixel read \nclock domain ->  synced with / controlled by the AXIS Aclk signal (Constant 100 Mhz)\nto read data and feed to VDMA.\nWhy use a FIFO anyway ?\nHandling the Clock Domain Crossing in an efficient way.\nHandling the Clock Domain Crossing in an efficient way.\nWe have two clock domains as explained previously:Pixel write clock domain -> synced\nwith / controlled by the pixel clock signal coming from the deserializer.Pixel read \nclock domain ->  synced with / controlled by the AXIS Aclk signal (Constant 100 Mhz)\nto read data and feed to VDMA.\nWe have two clock domains as explained previously:\nPixel write clock domain -> synced with / controlled by the pixel clock signal \ncoming from the deserializer.\nPixel write clock domain -> synced with / controlled by the pixel clock signal \ncoming from the deserializer.\nPixel read clock domain ->  synced with / controlled by the AXIS Aclk signal \n(Constant 100 Mhz) to read data and feed to VDMA.\nPixel read clock domain ->  synced with / controlled by the AXIS Aclk signal \n(Constant 100 Mhz) to read data and feed to VDMA.\nNo matter how fast / slow is the Pclk, VDMA can read Pixel data safely from the FIFO\nindependently.\nNo matter how fast / slow is the Pclk, VDMA can read Pixel data safely from the FIFO\nindependently.\nFIFO write enable = DE.FIFO read enable = VDMA_AXIS_Tready & Complete frame line is \nwritten in FIFO & FIFO is not empty.FIFO size = 2 ^ (#Address Lines) x (#Data \nLines)#Data Lines = 26  = 24 RGB Pixel data + SOF (1-bit) + EOL (1-bit)\nFIFO write enable = DE.\nFIFO write enable = DE.\nFIFO read enable = VDMA_AXIS_Tready & Complete frame line is written in FIFO & FIFO \nis not empty.\nFIFO read enable = VDMA_AXIS_Tready & Complete frame line is written in FIFO & FIFO \nis not empty.\nFIFO size = 2 ^ (#Address Lines) x (#Data Lines)\nFIFO size = 2 ^ (#Address Lines) x (#Data Lines)\n#Data Lines = 26  = 24 RGB Pixel data + SOF (1-bit) + EOL (1-bit)\n#Data Lines = 26  = 24 RGB Pixel data + SOF (1-bit) + EOL (1-bit)", "type": "Document"}}