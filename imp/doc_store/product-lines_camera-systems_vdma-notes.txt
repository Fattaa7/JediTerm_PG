{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "product-lines_camera-systems_vdma-notes.txt"}, "page_content": "VDMA Notes\nIn this article, we will go through the architecture of a very important building \nblock in video capture / stream systems, the VDMA. Also, we will explain the role of\nVDMA in our DVS projects and how we tweaked its parameters and interconnected it \nwith other system peripherals and the Microblaze microprocessor. All basic core info\nare fetched from the official core document by Xilinx.\nIntroduction\nAXI VDMA core is a soft Xilinx (IP) core providing high-bandwidth direct memory \naccess between SDram memory and AXI4-Stream                                         \n  video type target peripherals which support AXI4-Stream Video Protocol.AXI4-Stream\nvideo type target peripherals are like the \"v_axi4s_vid_out\" streaming core and \n\"v_vid_in_axi4s\" capture core.In the streaming solution (KC705 Kit), we are using \nVDMA version 6.3. Documentation could be foundhere.VDMA version 6.3 is not \ncompatible with Spartan-6.In Castle 5 projects, we are using VDMA version 5.04. \nDocumentation could be foundhere.\nAXI VDMA core is a soft Xilinx (IP) core providing high-bandwidth direct memory \naccess between SDram memory and AXI4-Stream                                         \n  video type target peripherals which support AXI4-Stream Video Protocol.\nAXI VDMA core is a soft Xilinx (IP) core providing high-bandwidth direct memory \naccess between SDram memory and AXI4-Stream                                         \n  video type target peripherals which support AXI4-Stream Video Protocol.\nAXI4-Stream video type target peripherals are like the \"v_axi4s_vid_out\" streaming \ncore and \"v_vid_in_axi4s\" capture core.\nAXI4-Stream video type target peripherals are like the \"v_axi4s_vid_out\" streaming \ncore and \"v_vid_in_axi4s\" capture core.\nIn the streaming solution (KC705 Kit), we are using VDMA version 6.3. Documentation \ncould be foundhere.\nIn the streaming solution (KC705 Kit), we are using VDMA version 6.3. Documentation \ncould be foundhere.\nVDMA version 6.3 is not compatible with Spartan-6.\nVDMA version 6.3 is not compatible with Spartan-6.\nIn Castle 5 projects, we are using VDMA version 5.04. Documentation could be \nfoundhere.\nIn Castle 5 projects, we are using VDMA version 5.04. Documentation could be \nfoundhere.\nOverview\nVDMA block diagram :\nVDMA block diagram :\nIt all starts with the MicroBlaze microprocessor, it configures the registers of the\nVDMA through the AXI4-Lite bus interface.Control/ Status (Cntl/Sts) state machine \nblock is changed accordingly. Allowing the DataMover to initiate Write and \nReadcommands on the AXI4 Memory Map Master interface.A configurable asynchronous \nline buffer is used to take care of frequency differences on both the Memory map and\nstreaming side interfaces.In the Write path (A core is writing video frames to VDMA \nover AXIS), the VDMA accepts frames on the AXI4-Stream Slave interface (S_AXIS_S2MM)\nand writes them to system memory using the AXI4 Memory Map Master interface :In \nCastle 5 architecture:This happens in thecapturemode, when Castle 5 is capturing a \nstatic frame from an input video to the PIP.\"v_vid_in_axi4s\" core captures a \nsnapshot from input video stream and writes it to VDMA though AXI4-Stream Slave \ninterface.                                      to be saved by VDMA to SDram through\nAXI4 bus interface.In streaming solution :This happens in \nbothCaptureandstreammodes.In streaming mode :SMUX is providing AXIS video data to \npatternMatcher to be provided to VDMA over AXIS.VDMA is then buffering the received \nvideo data in memory map over AXI4 to be saved there and retrieved later for \nstreaming.How does this happen ?The write and read processes are controlled by \nFsync.In VDMA 6.3, Fsync can have 4 options :In the Read path, the AXI VDMA uses the\nAXI4 Memory Map Master interface for reading frames from system memory (SDram) and \noutputs it                                  on the AXI4-Stream Master interface \n:This happens in theStreammode, when Castle 5 is streaming a static frame saved in \nSDram to the ECU.VDMA reads the frame from SDram and outputs it to AXI4-Stream to be\nprovided to \"v_axi4s_vid_out\" core for streaming.Both write and read paths operate \nindependently and in a full duplex like method.This is why - in all Castle 5 SVS \nprojects - we use axi_vdma_0 (first VDMA instance) for both, capturing and streaming\npurposes.VDMA supports parameterizing both AXI4 memory map bus interface width and \nAXI4-Stream Data Width with the following parameters \n:C_M_AXIS_MM2S_TDATA_WIDTHC_S_AXIS_S2MM_TDATA_WIDTHC_M_AXI_MM2S_DATA_WIDTHC_M_AXI_S2\nMM_DATA_WIDTHSuch features are project specific and should be tweaked per the video \nformat to be streamed / captured from Castle\nIt all starts with the MicroBlaze microprocessor, it configures the registers of the\nVDMA through the AXI4-Lite bus interface.\nIt all starts with the MicroBlaze microprocessor, it configures the registers of the\nVDMA through the AXI4-Lite bus interface.\nControl/ Status (Cntl/Sts) state machine block is changed accordingly. Allowing the \nDataMover to initiate Write and Readcommands on the AXI4 Memory Map Master \ninterface.\nControl/ Status (Cntl/Sts) state machine block is changed accordingly. Allowing the \nDataMover to initiate Write and Read\ncommands on the AXI4 Memory Map Master interface.\ncommands on the AXI4 Memory Map Master interface.\nA configurable asynchronous line buffer is used to take care of frequency \ndifferences on both the Memory map and streaming side interfaces.In the Write path \n(A core is writing video frames to VDMA over AXIS), the VDMA accepts frames on the \nAXI4-Stream Slave interface (S_AXIS_S2MM) and writes them to system memory using the\nAXI4 Memory Map Master interface :In Castle 5 architecture:This happens in \nthecapturemode, when Castle 5 is capturing a static frame from an input video to the\nPIP.\"v_vid_in_axi4s\" core captures a snapshot from input video stream and writes it \nto VDMA though AXI4-Stream Slave interface.                                      to \nbe saved by VDMA to SDram through AXI4 bus interface.\nA configurable asynchronous line buffer is used to take care of frequency \ndifferences on both the Memory map and streaming side interfaces.\nIn the Write path (A core is writing video frames to VDMA over AXIS), the VDMA \naccepts frames on the AXI4-Stream Slave interface (S_AXIS_S2MM) and writes them to \nsystem memory using the AXI4 Memory Map Master interface :\nIn the Write path (A core is writing video frames to VDMA over AXIS), the VDMA \naccepts frames on the AXI4-Stream Slave interface (S_AXIS_S2MM) and writes them to \nsystem memory using the AXI4 Memory Map Master interface :\nIn Castle 5 architecture:This happens in thecapturemode, when Castle 5 is capturing \na static frame from an input video to the PIP.\"v_vid_in_axi4s\" core captures a \nsnapshot from input video stream and writes it to VDMA though AXI4-Stream Slave \ninterface.                                      to be saved by VDMA to SDram through\nAXI4 bus interface.\nIn Castle 5 architecture:\nThis happens in thecapturemode, when Castle 5 is capturing a static frame from an \ninput video to the PIP.\nThis happens in thecapturemode, when Castle 5 is capturing a static frame from an \ninput video to the PIP.\n\"v_vid_in_axi4s\" core captures a snapshot from input video stream and writes it to \nVDMA though AXI4-Stream Slave interface.                                      to be \nsaved by VDMA to SDram through AXI4 bus interface.\n\"v_vid_in_axi4s\" core captures a snapshot from input video stream and writes it to \nVDMA though AXI4-Stream Slave interface.                                      to be \nsaved by VDMA to SDram through AXI4 bus interface.\nIn streaming solution :This happens in bothCaptureandstreammodes.In streaming mode \n:SMUX is providing AXIS video data to patternMatcher to be provided to VDMA over \nAXIS.VDMA is then buffering the received video data in memory map over AXI4 to be \nsaved there and retrieved later for streaming.\nIn streaming solution :\nThis happens in bothCaptureandstreammodes.In streaming mode :SMUX is providing AXIS \nvideo data to patternMatcher to be provided to VDMA over AXIS.VDMA is then buffering\nthe received video data in memory map over AXI4 to be saved there and retrieved \nlater for streaming.\nThis happens in bothCaptureandstreammodes.\nThis happens in bothCaptureandstreammodes.\nIn streaming mode :SMUX is providing AXIS video data to patternMatcher to be \nprovided to VDMA over AXIS.VDMA is then buffering the received video data in memory \nmap over AXI4 to be saved there and retrieved later for streaming.\nIn streaming mode :\nSMUX is providing AXIS video data to patternMatcher to be provided to VDMA over \nAXIS.\nSMUX is providing AXIS video data to patternMatcher to be provided to VDMA over \nAXIS.\nVDMA is then buffering the received video data in memory map over AXI4 to be saved \nthere and retrieved later for streaming.\nVDMA is then buffering the received video data in memory map over AXI4 to be saved \nthere and retrieved later for streaming.\nHow does this happen ?The write and read processes are controlled by Fsync.In VDMA \n6.3, Fsync can have 4 options :\nHow does this happen ?\nThe write and read processes are controlled by Fsync.In VDMA 6.3, Fsync can have 4 \noptions :\nThe write and read processes are controlled by Fsync.\nThe write and read processes are controlled by Fsync.\nIn VDMA 6.3, Fsync can have 4 options :\nIn VDMA 6.3, Fsync can have 4 options :\nIn the Read path, the AXI VDMA uses the AXI4 Memory Map Master interface for reading\nframes from system memory (SDram) and outputs it                                  on\nthe AXI4-Stream Master interface :This happens in theStreammode, when Castle 5 is \nstreaming a static frame saved in SDram to the ECU.VDMA reads the frame from SDram \nand outputs it to AXI4-Stream to be provided to \"v_axi4s_vid_out\" core for \nstreaming.\nIn the Read path, the AXI VDMA uses the AXI4 Memory Map Master interface for reading\nframes from system memory (SDram) and outputs it                                  on\nthe AXI4-Stream Master interface :\nThis happens in theStreammode, when Castle 5 is streaming a static frame saved in \nSDram to the ECU.\nThis happens in theStreammode, when Castle 5 is streaming a static frame saved in \nSDram to the ECU.\nVDMA reads the frame from SDram and outputs it to AXI4-Stream to be provided to \n\"v_axi4s_vid_out\" core for streaming.\nVDMA reads the frame from SDram and outputs it to AXI4-Stream to be provided to \n\"v_axi4s_vid_out\" core for streaming.\nBoth write and read paths operate independently and in a full duplex like method.\nBoth write and read paths operate independently and in a full duplex like method.\nThis is why - in all Castle 5 SVS projects - we use axi_vdma_0 (first VDMA instance)\nfor both, capturing and streaming purposes.\nThis is why - in all Castle 5 SVS projects - we use axi_vdma_0 (first VDMA instance)\nfor both, capturing and streaming purposes.\nVDMA supports parameterizing both AXI4 memory map bus interface width and \nAXI4-Stream Data Width with the following parameters \n:C_M_AXIS_MM2S_TDATA_WIDTHC_S_AXIS_S2MM_TDATA_WIDTHC_M_AXI_MM2S_DATA_WIDTHC_M_AXI_S2\nMM_DATA_WIDTHSuch features are project specific and should be tweaked per the video \nformat to be streamed / captured from Castle\nVDMA supports parameterizing both AXI4 memory map bus interface width and \nAXI4-Stream Data Width with the following parameters :\nC_M_AXIS_MM2S_TDATA_WIDTH\nC_M_AXIS_MM2S_TDATA_WIDTH\nC_S_AXIS_S2MM_TDATA_WIDTH\nC_S_AXIS_S2MM_TDATA_WIDTH\nC_M_AXI_MM2S_DATA_WIDTH\nC_M_AXI_MM2S_DATA_WIDTH\nC_M_AXI_S2MM_DATA_WIDTH\nC_M_AXI_S2MM_DATA_WIDTH\nSuch features are project specific and should be tweaked per the video format to be \nstreamed / captured from Castle\nSuch features are project specific and should be tweaked per the video format to be \nstreamed / captured from Castle\nData Realignment Engine :The AXI VDMA core supports the optional Data Realignment \nEngine (DRE).When the DRE is enabled, data reads/write can start from/to any start \naddress byte offset, horizontal size and stride value.This feature is deployed in \nall of our C5 DVS projects working with VDMA (for capture and stream purposes) \n:PARAMETER C_INCLUDE_MM2S_DRE = 1PARAMETER C_INCLUDE_S2MM_DRE = 1\nData Realignment Engine :\nThe AXI VDMA core supports the optional Data Realignment Engine (DRE).When the DRE \nis enabled, data reads/write can start from/to any start address byte offset, \nhorizontal size and stride value.This feature is deployed in all of our C5 DVS \nprojects working with VDMA (for capture and stream purposes) :PARAMETER \nC_INCLUDE_MM2S_DRE = 1PARAMETER C_INCLUDE_S2MM_DRE = 1\nThe AXI VDMA core supports the optional Data Realignment Engine (DRE).\nThe AXI VDMA core supports the optional Data Realignment Engine (DRE).\nWhen the DRE is enabled, data reads/write can start from/to any start address byte \noffset, horizontal size and stride value.\nWhen the DRE is enabled, data reads/write can start from/to any start address byte \noffset, horizontal size and stride value.\nThis feature is deployed in all of our C5 DVS projects working with VDMA (for \ncapture and stream purposes) :PARAMETER C_INCLUDE_MM2S_DRE = 1PARAMETER \nC_INCLUDE_S2MM_DRE = 1\nThis feature is deployed in all of our C5 DVS projects working with VDMA (for \ncapture and stream purposes) :\nPARAMETER C_INCLUDE_MM2S_DRE = 1\nPARAMETER C_INCLUDE_MM2S_DRE = 1\nPARAMETER C_INCLUDE_S2MM_DRE = 1\nPARAMETER C_INCLUDE_S2MM_DRE = 1\nLine Buffers and Store and Forward :The VDMA core supports an optional line buffer \nthat can be utilized to prevent memory controller throttling from causing           \n                                            inner packet throttling on the stream \ninterface.Line buffer parameters like empty and full signals are driven out of the \nAXI VDMA core for Video IP use.The AXI VDMA core also supports the optional \nStore-And-Forward feature.On the read path (MM2S), this prevents the channel from \nrequesting more read data than can be held in the Store-And-Forward                 \n                            buffer whereas on the write path (S2MM) Store and \nForward option is always enabled as incoming data size is indeterminate.\nLine Buffers and Store and Forward :\nThe VDMA core supports an optional line buffer that can be utilized to prevent \nmemory controller throttling from causing                                           \n            inner packet throttling on the stream interface.Line buffer parameters \nlike empty and full signals are driven out of the AXI VDMA core for Video IP use.The\nAXI VDMA core also supports the optional Store-And-Forward feature.On the read path \n(MM2S), this prevents the channel from requesting more read data than can be held in\nthe Store-And-Forward                                              buffer whereas on\nthe write path (S2MM) Store and Forward option is always enabled as incoming data \nsize is indeterminate.\nThe VDMA core supports an optional line buffer that can be utilized to prevent \nmemory controller throttling from causing                                           \n            inner packet throttling on the stream interface.\nThe VDMA core supports an optional line buffer that can be utilized to prevent \nmemory controller throttling from causing                                           \n            inner packet throttling on the stream interface.\nLine buffer parameters like empty and full signals are driven out of the AXI VDMA \ncore for Video IP use.\nLine buffer parameters like empty and full signals are driven out of the AXI VDMA \ncore for Video IP use.\nThe AXI VDMA core also supports the optional Store-And-Forward feature.\nThe AXI VDMA core also supports the optional Store-And-Forward feature.\nOn the read path (MM2S), this prevents the channel from requesting more read data \nthan can be held in the Store-And-Forward                                           \n  buffer whereas on the write path (S2MM) Store and Forward option is always enabled\nas incoming data size is indeterminate.\nOn the read path (MM2S), this prevents the channel from requesting more read data \nthan can be held in the Store-And-Forward                                           \n  buffer whereas on the write path (S2MM) Store and Forward option is always enabled\nas incoming data size is indeterminate.\nFrame Sync :VDMA supports an optional TUSER bus on both MM2S and S2MM AXIS \ninterfaces.MM2S and S2MM AXIS are the interfaces between VDMA and (v_vid_in_axi4s & \nv_axi4s_vid_out) cores.TUSER(0) is used for a Start of Frame (SOF) or external frame\nsync.When enabled (C_MM2S_SOF_ENABLE=1), MM2S channel will drive frame sync out on \nm_axis_mm2s_tuser(0).When enabled (C_S2MM_SOF_ENABLE=1) and (S2MM_DMACR[6:5] = 10), \nS2MM channel will sync to frame sync in on s_axis_s2mm_tuser(0).\nFrame Sync :\nVDMA supports an optional TUSER bus on both MM2S and S2MM AXIS interfaces.MM2S and \nS2MM AXIS are the interfaces between VDMA and (v_vid_in_axi4s & v_axi4s_vid_out) \ncores.TUSER(0) is used for a Start of Frame (SOF) or external frame sync.When \nenabled (C_MM2S_SOF_ENABLE=1), MM2S channel will drive frame sync out on \nm_axis_mm2s_tuser(0).When enabled (C_S2MM_SOF_ENABLE=1) and (S2MM_DMACR[6:5] = 10), \nS2MM channel will sync to frame sync in on s_axis_s2mm_tuser(0).\nVDMA supports an optional TUSER bus on both MM2S and S2MM AXIS interfaces.\nVDMA supports an optional TUSER bus on both MM2S and S2MM AXIS interfaces.\nMM2S and S2MM AXIS are the interfaces between VDMA and (v_vid_in_axi4s & \nv_axi4s_vid_out) cores.\nMM2S and S2MM AXIS are the interfaces between VDMA and (v_vid_in_axi4s & \nv_axi4s_vid_out) cores.\nTUSER(0) is used for a Start of Frame (SOF) or external frame sync.\nTUSER(0) is used for a Start of Frame (SOF) or external frame sync.\nWhen enabled (C_MM2S_SOF_ENABLE=1), MM2S channel will drive frame sync out on \nm_axis_mm2s_tuser(0).\nWhen enabled (C_MM2S_SOF_ENABLE=1), MM2S channel will drive frame sync out on \nm_axis_mm2s_tuser(0).\nWhen enabled (C_S2MM_SOF_ENABLE=1) and (S2MM_DMACR[6:5] = 10),  S2MM channel will \nsync to frame sync in on s_axis_s2mm_tuser(0).\nWhen enabled (C_S2MM_SOF_ENABLE=1) and (S2MM_DMACR[6:5] = 10),  S2MM channel will \nsync to frame sync in on s_axis_s2mm_tuser(0).\n32 Frame Stores :VDMA supports a maximum of 32 frame stores.MM2S_REG_INDEX and \nS2MM_REG_INDEX need to be set to access start addresses of 16 to 32 frame stores in \nread (MM2S) and                                      write (S2MM) paths \nrespectively.In this mode, MM2S_REG_INDEX and S2MM_REG_INDEX are added to create \nanother set of register bank of 16 frame stores.This is done to keep it backward \ncompatible with AXI VDMA previous versions.\n32 Frame Stores :\nVDMA supports a maximum of 32 frame stores.MM2S_REG_INDEX and S2MM_REG_INDEX need to\nbe set to access start addresses of 16 to 32 frame stores in read (MM2S) and        \n                              write (S2MM) paths respectively.In this mode, \nMM2S_REG_INDEX and S2MM_REG_INDEX are added to create another set of register bank \nof 16 frame stores.This is done to keep it backward compatible with AXI VDMA \nprevious versions.\nVDMA supports a maximum of 32 frame stores.\nVDMA supports a maximum of 32 frame stores.\nMM2S_REG_INDEX and S2MM_REG_INDEX need to be set to access start addresses of 16 to \n32 frame stores in read (MM2S) and                                      write (S2MM)\npaths respectively.\nMM2S_REG_INDEX and S2MM_REG_INDEX need to be set to access start addresses of 16 to \n32 frame stores in read (MM2S) and                                      write (S2MM)\npaths respectively.\nIn this mode, MM2S_REG_INDEX and S2MM_REG_INDEX are added to create another set of \nregister bank of 16 frame stores.\nIn this mode, MM2S_REG_INDEX and S2MM_REG_INDEX are added to create another set of \nregister bank of 16 frame stores.\nThis is done to keep it backward compatible with AXI VDMA previous versions.\nThis is done to keep it backward compatible with AXI VDMA previous versions.\nDynamic Clock Frequency Change on AXI4-Stream Interface :The AXI VDMA core allows \nyou to change the primary data path clocks dynamically to support different video \nresolutions without rebuilding the system.\nDynamic Clock Frequency Change on AXI4-Stream Interface :\nThe AXI VDMA core allows you to change the primary data path clocks dynamically to \nsupport different video resolutions without rebuilding the system.\nThe AXI VDMA core allows you to change the primary data path clocks dynamically to \nsupport different video resolutions without rebuilding the system.\nThe AXI VDMA core allows you to change the primary data path clocks dynamically to \nsupport different video resolutions without rebuilding the system.\nDynamic Line Buffer Threshold :This feature allows the almost empty and almost full \nthreshold values to be dynamically changed by accessing new threshold registers.\nDynamic Line Buffer Threshold :\nThis feature allows the almost empty and almost full threshold values to be \ndynamically changed by accessing new threshold registers.\nThis feature allows the almost empty and almost full threshold values to be \ndynamically changed by accessing new threshold registers.\nThis feature allows the almost empty and almost full threshold values to be \ndynamically changed by accessing new threshold registers.\nFlush on Frame Sync :The flush on frame sync feature allows VDMA to reset internal \nstates and flush line buffer on frame sync for certain error conditions.This allows \nAXI VDMA to restart transfers at the beginning of the next new frame after DMA \nInternal error detection instead of halting the channelThis feature is added for \nboth MM2S and S2MM channels independently.\nFlush on Frame Sync :\nThe flush on frame sync feature allows VDMA to reset internal states and flush line \nbuffer on frame sync for certain error conditions.This allows AXI VDMA to restart \ntransfers at the beginning of the next new frame after DMA Internal error detection \ninstead of halting the channelThis feature is added for both MM2S and S2MM channels \nindependently.\nThe flush on frame sync feature allows VDMA to reset internal states and flush line \nbuffer on frame sync for certain error conditions.\nThe flush on frame sync feature allows VDMA to reset internal states and flush line \nbuffer on frame sync for certain error conditions.\nThis allows AXI VDMA to restart transfers at the beginning of the next new frame \nafter DMA Internal error detection instead of halting the channel\nThis allows AXI VDMA to restart transfers at the beginning of the next new frame \nafter DMA Internal error detection instead of halting the channel\nThis feature is added for both MM2S and S2MM channels independently.\nThis feature is added for both MM2S and S2MM channels independently.\nHSync Period :HSync period is the time taken by the IP to process one line.\nHSync Period :\nHSync period is the time taken by the IP to process one line.\nHSync period is the time taken by the IP to process one line.\nHSync period is the time taken by the IP to process one line.\nC_NUM_FSTORES :This integer parameter is used to define the maximum number of frame \nstorage locations to be processed by the AXI VDMA.\nC_NUM_FSTORES :\nThis integer parameter is used to define the maximum number of frame storage \nlocations to be processed by the AXI VDMA.\nThis integer parameter is used to define the maximum number of frame storage \nlocations to be processed by the AXI VDMA.\nThis integer parameter is used to define the maximum number of frame storage \nlocations to be processed by the AXI VDMA.\nC_USE_FSYNC:0 = Free run mode, 1 = Both channels in frame sync mode, 2 = Only MM2S \nchannel in frame sync mode, 3 = Only S2MM channel in frame sync modeThis integer \nparameter is used to set the synchronization mode of VDMA.When in free mode, the AXI\nVDMA transfers data as quickly as it is able to.When in frame sync mode, the AXI \nVDMA transfers data starting with the falling edge of each mm2s_fsync or s2mm_fsync \nfor the associated channel.For free run mode an internal fsync is generated for \ntiming transfers.AXI VDMA transfers the commanded transfers as quickly as it is able\nto process and transfer the data.AXI VDMA will drive out an fsync_out for the \nassociated channel, mm2s_fsync_out or s2mm_fsync_out, on each frame boundary.\nC_USE_FSYNC:0 = Free run mode, 1 = Both channels in frame sync mode, 2 = Only MM2S \nchannel in frame sync mode, 3 = Only S2MM channel in frame sync modeThis integer \nparameter is used to set the synchronization mode of VDMA.When in free mode, the AXI\nVDMA transfers data as quickly as it is able to.When in frame sync mode, the AXI \nVDMA transfers data starting with the falling edge of each mm2s_fsync or s2mm_fsync \nfor the associated channel.For free run mode an internal fsync is generated for \ntiming transfers.AXI VDMA transfers the commanded transfers as quickly as it is able\nto process and transfer the data.AXI VDMA will drive out an fsync_out for the \nassociated channel, mm2s_fsync_out or s2mm_fsync_out, on each frame boundary.\nC_USE_FSYNC:\n0 = Free run mode, 1 = Both channels in frame sync mode, 2 = Only MM2S channel in \nframe sync mode, 3 = Only S2MM channel in frame sync mode\n0 = Free run mode, 1 = Both channels in frame sync mode, 2 = Only MM2S channel in \nframe sync mode, 3 = Only S2MM channel in frame sync mode\nThis integer parameter is used to set the synchronization mode of VDMA.\nThis integer parameter is used to set the synchronization mode of VDMA.\nWhen in free mode, the AXI VDMA transfers data as quickly as it is able to.\nWhen in free mode, the AXI VDMA transfers data as quickly as it is able to.\nWhen in frame sync mode, the AXI VDMA transfers data starting with the falling edge \nof each mm2s_fsync or s2mm_fsync for the associated channel.\nWhen in frame sync mode, the AXI VDMA transfers data starting with the falling edge \nof each mm2s_fsync or s2mm_fsync for the associated channel.\nFor free run mode an internal fsync is generated for timing transfers.\nFor free run mode an internal fsync is generated for timing transfers.\nAXI VDMA transfers the commanded transfers as quickly as it is able to process and \ntransfer the data.\nAXI VDMA transfers the commanded transfers as quickly as it is able to process and \ntransfer the data.\nAXI VDMA will drive out an fsync_out for the associated channel, mm2s_fsync_out or \ns2mm_fsync_out, on each frame boundary.\nAXI VDMA will drive out an fsync_out for the associated channel, mm2s_fsync_out or \ns2mm_fsync_out, on each frame boundary.\nImportant VDMA I/O Signal Description :s_axi_lite_aclk:i: VDMA AXI4-Lite (with \nMicroBlaze) interface clock. \"S_\" means that VDMA is a slave to MicroBlaze in this \nbus interface.m_axi_mm2s_aclk:i: VDMA MM2S clock. AXI4 interface (to read from \nSDram) clock. \"M_\" means that VDMA is a master to memory map in this bus \ninterface.m_axi_s2mm_aclk:i: VDMA S2MM clock. AXI4 interface (to write to SDram ) \nclock. \"M_\" means that VDMA is a master to memory map in this bus \ninterface.s_axis_s2mm_aclk:i: VDMA S2MM AXIS clock. AXIS interface (to read from \nv_vid_in_axi4s)m_axis_mm2s_aclk:i: VDMA MM2S AXIS clock. AXIS interface (to write to\nv_axi4s_vid_out)mm2s_introut:o: Interrupt Out for Memory Map to Stream \nChannel.s2mm_introut:o: Interrupt Out for Stream to Memory Map Channel.mm2s_fsync : \ni :MM2S Frame Sync Input (output from video_test_src core) . When enabled, VDMA \nOperations begin on each falling edge of fsync.mm2s_fsync_out : o :MM2S Frame Sync \nOutput. This signal asserts High for one m_axis_mm2s_aclk cycle with each frame \nboundary indicating start of frame on MM2S streaming interface.s2mm_fsync : i: S2MM \nFrame Sync Input (output from video_test_src core) . When enabled, VDMA operations \nbegin on each falling edge of fsync.s2mm_fsync_out:o :This signal asserts High to \nIndicate new frame data can be transferred to the S2MM channel by video IP \n(v_vid_in_axi4s).mm2s_buffer_empty,mm2s_buffer_almost_empty,s2mm_buffer_full,s2mm_bu\nffer_almost_full: Cap & Stream Line buffers empty & full flagss_axis_s2mm_tdata : i \n:AXI4-Stream Data In (from v_vid_in_axi4s)s_axis_s2mm_tkeep : i:  AXI4-Stream Write \nKeep (from v_vid_in_axi4s). Indicates valid bytes on stream data. (For most use \ncases, all bytes are valid.). It needs to be tied High if stream master does not \nhave this signal.s_axis_s2mm_tuser: i : AXI4-Stream user bits (from v_vid_in_axi4s).\nThe signal tuser(0) receives in s2mm start of frame (SOF). VDMA expects this signal \nto be asserted for one clock period only.s_axis_s2mm_tvalid : i :Indicates stream \ndata bus (from v_vid_in_axi4s) s_axis_s2mm_tdata, is valid.s_axis_s2mm_tready : o \n:Indicates (to v_vid_in_axi4s) S2MM channel stream interface ready to receive stream\ndata.s_axis_s2mm_tlast : i :Indicates last data beat of stream data (input from \nv_vid_in_axi4s) .m_axis_mm2s_tdata: o : AXI4-Stream Data Out (to \nv_axi4s_vid_out)m_axis_mm2s_tkeep: o : AXI4-Stream Write Keep (to v_axi4s_vid_out). \nIndicates valid bytes on stream data.m_axis_mm2s_tuser: o : AXI4-Stream user bits. \ntuser(0) drives out mm2s start of frame (SOF) (to \nv_axi4s_vid_out)m_axis_mm2s_tvalid: o : Indicates stream data bus, \nm_axis_mm2s_tdata, is valid (to v_axi4s_vid_out)m_axis_mm2s_tready : i :Indicates \n(from v_axi4s_vid_out) MM2S channel stream interface ready to receive stream data.\nImportant VDMA I/O Signal Description :\ns_axi_lite_aclk:i: VDMA AXI4-Lite (with MicroBlaze) interface clock. \"S_\" means that\nVDMA is a slave to MicroBlaze in this bus interface.m_axi_mm2s_aclk:i: VDMA MM2S \nclock. AXI4 interface (to read from SDram) clock. \"M_\" means that VDMA is a master \nto memory map in this bus interface.m_axi_s2mm_aclk:i: VDMA S2MM clock. AXI4 \ninterface (to write to SDram ) clock. \"M_\" means that VDMA is a master to memory map\nin this bus interface.s_axis_s2mm_aclk:i: VDMA S2MM AXIS clock. AXIS interface (to \nread from v_vid_in_axi4s)m_axis_mm2s_aclk:i: VDMA MM2S AXIS clock. AXIS interface \n(to write to v_axi4s_vid_out)mm2s_introut:o: Interrupt Out for Memory Map to Stream \nChannel.s2mm_introut:o: Interrupt Out for Stream to Memory Map Channel.mm2s_fsync : \ni :MM2S Frame Sync Input (output from video_test_src core) . When enabled, VDMA \nOperations begin on each falling edge of fsync.mm2s_fsync_out : o :MM2S Frame Sync \nOutput. This signal asserts High for one m_axis_mm2s_aclk cycle with each frame \nboundary indicating start of frame on MM2S streaming interface.s2mm_fsync : i: S2MM \nFrame Sync Input (output from video_test_src core) . When enabled, VDMA operations \nbegin on each falling edge of fsync.s2mm_fsync_out:o :This signal asserts High to \nIndicate new frame data can be transferred to the S2MM channel by video IP \n(v_vid_in_axi4s).mm2s_buffer_empty,mm2s_buffer_almost_empty,s2mm_buffer_full,s2mm_bu\nffer_almost_full: Cap & Stream Line buffers empty & full flagss_axis_s2mm_tdata : i \n:AXI4-Stream Data In (from v_vid_in_axi4s)s_axis_s2mm_tkeep : i:  AXI4-Stream Write \nKeep (from v_vid_in_axi4s). Indicates valid bytes on stream data. (For most use \ncases, all bytes are valid.). It needs to be tied High if stream master does not \nhave this signal.s_axis_s2mm_tuser: i : AXI4-Stream user bits (from v_vid_in_axi4s).\nThe signal tuser(0) receives in s2mm start of frame (SOF). VDMA expects this signal \nto be asserted for one clock period only.s_axis_s2mm_tvalid : i :Indicates stream \ndata bus (from v_vid_in_axi4s) s_axis_s2mm_tdata, is valid.s_axis_s2mm_tready : o \n:Indicates (to v_vid_in_axi4s) S2MM channel stream interface ready to receive stream\ndata.s_axis_s2mm_tlast : i :Indicates last data beat of stream data (input from \nv_vid_in_axi4s) .m_axis_mm2s_tdata: o : AXI4-Stream Data Out (to \nv_axi4s_vid_out)m_axis_mm2s_tkeep: o : AXI4-Stream Write Keep (to v_axi4s_vid_out). \nIndicates valid bytes on stream data.m_axis_mm2s_tuser: o : AXI4-Stream user bits. \ntuser(0) drives out mm2s start of frame (SOF) (to \nv_axi4s_vid_out)m_axis_mm2s_tvalid: o : Indicates stream data bus, \nm_axis_mm2s_tdata, is valid (to v_axi4s_vid_out)m_axis_mm2s_tready : i :Indicates \n(from v_axi4s_vid_out) MM2S channel stream interface ready to receive stream data.\ns_axi_lite_aclk:i: VDMA AXI4-Lite (with MicroBlaze) interface clock. \"S_\" means that\nVDMA is a slave to MicroBlaze in this bus interface.\ns_axi_lite_aclk:i: VDMA AXI4-Lite (with MicroBlaze) interface clock. \"S_\" means that\nVDMA is a slave to MicroBlaze in this bus interface.\nm_axi_mm2s_aclk:i: VDMA MM2S clock. AXI4 interface (to read from SDram) clock. \"M_\" \nmeans that VDMA is a master to memory map in this bus interface.\nm_axi_mm2s_aclk:i: VDMA MM2S clock. AXI4 interface (to read from SDram) clock. \"M_\" \nmeans that VDMA is a master to memory map in this bus interface.\nm_axi_s2mm_aclk:i: VDMA S2MM clock. AXI4 interface (to write to SDram ) clock. \"M_\" \nmeans that VDMA is a master to memory map in this bus interface.\nm_axi_s2mm_aclk:i: VDMA S2MM clock. AXI4 interface (to write to SDram ) clock. \"M_\" \nmeans that VDMA is a master to memory map in this bus interface.\ns_axis_s2mm_aclk:i: VDMA S2MM AXIS clock. AXIS interface (to read from \nv_vid_in_axi4s)\ns_axis_s2mm_aclk:i: VDMA S2MM AXIS clock. AXIS interface (to read from \nv_vid_in_axi4s)\nm_axis_mm2s_aclk:i: VDMA MM2S AXIS clock. AXIS interface (to write to \nv_axi4s_vid_out)\nm_axis_mm2s_aclk:i: VDMA MM2S AXIS clock. AXIS interface (to write to \nv_axi4s_vid_out)\nmm2s_introut:o: Interrupt Out for Memory Map to Stream Channel.\nmm2s_introut:o: Interrupt Out for Memory Map to Stream Channel.\ns2mm_introut:o: Interrupt Out for Stream to Memory Map Channel.\ns2mm_introut:o: Interrupt Out for Stream to Memory Map Channel.\nmm2s_fsync : i :MM2S Frame Sync Input (output from video_test_src core) . When \nenabled, VDMA Operations begin on each falling edge of fsync.\nmm2s_fsync : i :MM2S Frame Sync Input (output from video_test_src core) . When \nenabled, VDMA Operations begin on each falling edge of fsync.\nmm2s_fsync_out : o :MM2S Frame Sync Output. This signal asserts High for one \nm_axis_mm2s_aclk cycle with each frame boundary indicating start of frame on MM2S \nstreaming interface.\nmm2s_fsync_out : o :MM2S Frame Sync Output. This signal asserts High for one \nm_axis_mm2s_aclk cycle with each frame boundary indicating start of frame on MM2S \nstreaming interface.\ns2mm_fsync : i: S2MM Frame Sync Input (output from video_test_src core) . When \nenabled, VDMA operations begin on each falling edge of fsync.\ns2mm_fsync : i: S2MM Frame Sync Input (output from video_test_src core) . When \nenabled, VDMA operations begin on each falling edge of fsync.\ns2mm_fsync_out:o :This signal asserts High to Indicate new frame data can be \ntransferred to the S2MM channel by video IP (v_vid_in_axi4s).\ns2mm_fsync_out:o :This signal asserts High to Indicate new frame data can be \ntransferred to the S2MM channel by video IP (v_vid_in_axi4s).\nmm2s_buffer_empty,mm2s_buffer_almost_empty,s2mm_buffer_full,s2mm_buffer_almost_full:\nCap & Stream Line buffers empty & full flags\nmm2s_buffer_empty,mm2s_buffer_almost_empty,s2mm_buffer_full,s2mm_buffer_almost_full:\nCap & Stream Line buffers empty & full flags\ns_axis_s2mm_tdata : i :AXI4-Stream Data In (from v_vid_in_axi4s)\ns_axis_s2mm_tdata : i :AXI4-Stream Data In (from v_vid_in_axi4s)\ns_axis_s2mm_tkeep : i:  AXI4-Stream Write Keep (from v_vid_in_axi4s). Indicates \nvalid bytes on stream data. (For most use cases, all bytes are valid.). It needs to \nbe tied High if stream master does not have this signal.\ns_axis_s2mm_tkeep : i:  AXI4-Stream Write Keep (from v_vid_in_axi4s). Indicates \nvalid bytes on stream data. (For most use cases, all bytes are valid.). It needs to \nbe tied High if stream master does not have this signal.\ns_axis_s2mm_tuser: i : AXI4-Stream user bits (from v_vid_in_axi4s). The signal \ntuser(0) receives in s2mm start of frame (SOF). VDMA expects this signal to be \nasserted for one clock period only.\ns_axis_s2mm_tuser: i : AXI4-Stream user bits (from v_vid_in_axi4s). The signal \ntuser(0) receives in s2mm start of frame (SOF). VDMA expects this signal to be \nasserted for one clock period only.\ns_axis_s2mm_tvalid : i :Indicates stream data bus (from v_vid_in_axi4s) \ns_axis_s2mm_tdata, is valid.\ns_axis_s2mm_tvalid : i :Indicates stream data bus (from v_vid_in_axi4s) \ns_axis_s2mm_tdata, is valid.\ns_axis_s2mm_tready : o :Indicates (to v_vid_in_axi4s) S2MM channel stream interface \nready to receive stream data.\ns_axis_s2mm_tready : o :Indicates (to v_vid_in_axi4s) S2MM channel stream interface \nready to receive stream data.\ns_axis_s2mm_tlast : i :Indicates last data beat of stream data (input from \nv_vid_in_axi4s) .\ns_axis_s2mm_tlast : i :Indicates last data beat of stream data (input from \nv_vid_in_axi4s) .\nm_axis_mm2s_tdata: o : AXI4-Stream Data Out (to v_axi4s_vid_out)\nm_axis_mm2s_tdata: o : AXI4-Stream Data Out (to v_axi4s_vid_out)\nm_axis_mm2s_tkeep: o : AXI4-Stream Write Keep (to v_axi4s_vid_out). Indicates valid \nbytes on stream data.\nm_axis_mm2s_tkeep: o : AXI4-Stream Write Keep (to v_axi4s_vid_out). Indicates valid \nbytes on stream data.\nm_axis_mm2s_tuser: o : AXI4-Stream user bits. tuser(0) drives out mm2s start of \nframe (SOF) (to v_axi4s_vid_out)\nm_axis_mm2s_tuser: o : AXI4-Stream user bits. tuser(0) drives out mm2s start of \nframe (SOF) (to v_axi4s_vid_out)\nm_axis_mm2s_tvalid: o : Indicates stream data bus, m_axis_mm2s_tdata, is valid (to \nv_axi4s_vid_out)\nm_axis_mm2s_tvalid: o : Indicates stream data bus, m_axis_mm2s_tdata, is valid (to \nv_axi4s_vid_out)\nm_axis_mm2s_tready : i :Indicates (from v_axi4s_vid_out) MM2S channel stream \ninterface ready to receive stream data.\nm_axis_mm2s_tready : i :Indicates (from v_axi4s_vid_out) MM2S channel stream \ninterface ready to receive stream data.\nm_axis_mm2s_tlast : o :AXI4-Stream Last. Indicates (to v_axi4s_vid_out) last data \nbeat of stream data.\nm_axis_mm2s_tlast : o :AXI4-Stream Last. Indicates (to v_axi4s_vid_out) last data \nbeat of stream data.\nm_axis_mm2s_tlast : o :AXI4-Stream Last. Indicates (to v_axi4s_vid_out) last data \nbeat of stream data.\nClockingAXI VDMA provides two clocking modes of operation: asynchronous and \nsynchronous.In async mode DMA control, Scatter Gather Engine, MM2S and S2MM Primary \ndatapaths can all run asynchronously from each other.We are operating the VDMA in \nAsynch. mode in Castle 5 SVS projects. As DMA data flow from SDram is running \nindependently of  MM2S & S2MM Streams.PARAMETERC_PRMRY_IS_ACLK_ASYNC= 1 in MHS\nClocking\nAXI VDMA provides two clocking modes of operation: asynchronous and synchronous.In \nasync mode DMA control, Scatter Gather Engine, MM2S and S2MM Primary datapaths can \nall run asynchronously from each other.We are operating the VDMA in Asynch. mode in \nCastle 5 SVS projects. As DMA data flow from SDram is running independently of  MM2S\n& S2MM Streams.PARAMETERC_PRMRY_IS_ACLK_ASYNC= 1 in MHS\nAXI VDMA provides two clocking modes of operation: asynchronous and synchronous.\nAXI VDMA provides two clocking modes of operation: asynchronous and synchronous.\nIn async mode DMA control, Scatter Gather Engine, MM2S and S2MM Primary datapaths \ncan all run asynchronously from each other.\nIn async mode DMA control, Scatter Gather Engine, MM2S and S2MM Primary datapaths \ncan all run asynchronously from each other.\nWe are operating the VDMA in Asynch. mode in Castle 5 SVS projects. As DMA data flow\nfrom SDram is running independently of  MM2S & S2MM Streams.\nWe are operating the VDMA in Asynch. mode in Castle 5 SVS projects. As DMA data flow\nfrom SDram is running independently of  MM2S & S2MM Streams.\nPARAMETERC_PRMRY_IS_ACLK_ASYNC= 1 in MHS\nPARAMETERC_PRMRY_IS_ACLK_ASYNC= 1 in MHS", "type": "Document"}}