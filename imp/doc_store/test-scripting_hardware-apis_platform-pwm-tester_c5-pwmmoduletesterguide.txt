{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "test-scripting_hardware-apis_platform-pwm-tester_c5-pwmmoduletesterguide.txt"}, "page_content": "C5 - PWM Module Tester Guide\nPost date: Mar 1, 2016 4:17:23 PM\nFirst of all I would quote the following description fromC5 Detail Doc\nThe signal is measured in 2 ways always.\n1. Per period, starting with the rising edge. This measures the period and pulse \nduration and builds min/max values for both values.\n2. Continuously tick based. One counter count the ticks (PeriodTicks) and another \ncounter counts the ticks where the signal is high (PulseTicks).\nThe quotient between both is the ratio value, measured in 0 .. 100%.\nSecond, I will write down three testing examples (On UPA_LED):\n1. Test that a PWM signal is happening\nexu.modTS().objPWM_LED_UPA().afcReadNow(true); // This will make a read and a reset.\nThe read is ignored. We just need the reset\nexu.pause(1000); // tune this according to the window you like\nexu.modTS().objPWM_LED_UPA().afcReadNow(true); // This will make a read and a reset.\nHere we need the read. The read contains the result since last reset till now (in \nthis example for the past second)\n// All the next tests will be run according to this read\nexu.pauseStandard();\nexu.modTS().objPWM_LED_UPA().objPeriodCount().afcInRangeCheck(20, 20, 25, 25);  // \nto check that in the past 1000 ms, there was 20 to 25 complete cycles in the PWM\nexu.pauseStandard();\nexu.modTS().objPWM_LED_UPA().objPeriodWidthMax().afcInRangeCheck(20000, 20000, \n25000, 25000);  // to check that thebiggest periodis between 20 and 25 ms\nexu.pauseStandard();\nexu.modTS().objPWM_LED_UPA().objPeriodWidthMin().afcInRangeCheck(20000, 20000, \n25000, 25000);\n// to check that thesmallest periodis between 20 and 25 ms\nexu.pauseStandard();\nexu.modTS().objPWM_LED_UPA().objPulseWidthMax().afcInRangeCheck(20000, 20000, 25000,\n25000);  // to check that thebiggest pulseis between 20 and 25 ms\nexu.pauseStandard();\nexu.modTS().objPWM_LED_UPA().objPulseWidthMin().afcInRangeCheck(20000, 20000, 25000,\n25000);\n// to check that thesmallest pulseis between 20 and 25 ms\n2. Test that the signal is constant High\nexu.modTS().objPWM_LED_UPA().afcReadNow(true); // This will make a read and a reset.\nThe read is ignored. We just need the reset\nexu.pause(1000); // tune this according to the window you like\nexu.modTS().objPWM_LED_UPA().afcReadNow(true); // This will make a read and a reset.\nHere we need the read. The read contains the result since last reset till now (in \nthis example for the past second)\n// All the next tests will be run according to this read\nexu.pauseStandard();\nexu.modTS().objPWM_LED_UPA().objRatio().afcEqualsCheck(100);  // Pulse Ticks / \nPeriod Ticks = 100%\n3. Test that the signal is constant Low\nexu.modTS().objPWM_LED_UPA().afcReadNow(true); // This will make a read and a reset.\nThe read is ignored. We just need the reset\nexu.pause(1000); // tune this according to the window you like\nexu.modTS().objPWM_LED_UPA().afcReadNow(true); // This will make a read and a reset.\nHere we need the read. The read contains the result since last reset till now (in \nthis example for the past second)\n// All the next tests will be run according to this read\nexu.pauseStandard();\nexu.modTS().objPWM_LED_UPA().objRatio().afcEqualsCheck(0);  // Pulse Ticks / Period \nTicks = 0%\nAnd\nSame for PSM Led, but use objPWM_LED_UPA(), instead of objPWM_LED_UPA, also the same\nfor any other PWM signal.", "type": "Document"}}