{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "EthernetSocket.md"}, "page_content": "### Function: Bind\n\n**Description:** Description: Purpose: Bind socket to specific ip and port (with support of vlanId if needed) Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcBind(); Dependency: should be called after init (if init is used, see the _init API document, otherwise it should be called first) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | MinLength | Maxlength |\n|---|---|---|---|---|\n| VlanSupported | boolean | bool | - | - |\n| boolean to specify whether the user will use virtual lan. true value will allow virtual lan virtual lan: is a logical subdivision of a physical Ethernet network, enabling devices to be grouped together regardless of their physical locations. Virtual lans work on layer 2 of network stack (Network layer) so, devices within the same virtual lan can communicate the data directly without routing capabilities, if some socket within specific virtual lan want to send data to other socket in other virtual lan, it need to use layer 3, routing capabilities |  |  |  |  |\n| VlanId | int | uint16 | - | - |\n| Virtual lan id, it can be project specific or defined randomly for testing prupose |  |  |  |  |\n| isIpV6 | boolean | bool | - | - |\n| boolean to specify whether the user will use Ipv6, 'true' value will allow Ipv6 |  |  |  |  |\n| TpType | TpType | int | - | - |\n| transport layer: could be Tcp or Udp |  |  |  |  |\n| SourceIP | int[] | uint32 | 4 | 4 |\n| source/local ip for castle input example: [192,168,144,11] for ipv4 ipv4 is 4 bytes while ipv6 is 16 bytes Note that: you should consider the subnet that is the destination ip is part of. Although layer 3 of network stack can handle communication between different subnets (by routing the data to default gateway/router), usually with castle project we don't use routers. so for example if the destination ip is 10.144.13.1, you should use source ip in the same subnet (10.144.13.2 for example) |  |  |  |  |\n| SourcePort | int | uint16 | - | - |\n| source/local port for castle input example: 52000, setting port to zero will let the network stack to choose random source port input range: 0 - 65535 Well-Known Ports (0\u20131023), Registered Ports (1024\u201349151), Dynamic or Private Ports (49152\u201365535) |  |  |  |  |\n\n\n---\n\n### Function: CheckTcpConnectionEstablished\n\n**Description:** Description: Purpose: Check that TCP connection is established successfully. a connection can be refused by the remote side (normally by sending RST signal) so,you may need to check it with this API Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcCheckTcpConnectionEstablished() Dependency: Should be called after 'Connect' API to check if the connection is successfully established. Result: You will get a response indicating whether the connection is established Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Default |\n|---|---|---|---|\n| CheckIsEstablished | boolean | bool | true |\n\n\n---\n\n### Function: Close\n\n**Description:** Description: Purpose: Closes the TCP connection and initiates the connection termination process with configurable Maximum Segment Lifetime (MSL). Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcClose( ) Dependency: Should be called on a successfully established connection Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Unit | Default |\n|---|---|---|---|---|\n| MSL | int | uint32 | ms | 0 |\n| Time before deleting the pcb at all after sending the first FIN symbol. [\"0\" value means to wait for the standard MSL which is 2 mins] |  |  |  |  |\n\n\n---\n\n### Function: ConfigureFastAck\n\n**Description:** Description: Purpose: Configures the TCP Fast ACK mechanism to control immediate acknowledgment behavior Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcConfigureFastAck(true) Dependency: Should be called after 'bind' API and before establishing connection using 'Connect' API Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Enable | boolean | bool |\n| Enable or disable Fast ACK. When enabled (true), ACKs are sent immediately. When disabled (false), ACKs may be delayed and combined. |  |  |\n\n\n---\n\n### Function: ConfigureNagleAlgorithm\n\n**Description:** Description: Purpose: Configures Nagle's algorithm which controls the buffering of small packets in TCP to reduce network overhead Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcConfigureNagleAlgorithm(true) Dependency: Should be called after 'bind' API and before establishing connection using 'Connect' API Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Enable | boolean | bool |\n| Enable or disable Nagle's algorithm. When enabled (true), small packets are buffered and combined. When disabled (false), packets are sent immediately. |  |  |\n\n\n---\n\n### Function: Connect\n\n**Description:** Description: Purpose: Connect Castle as a client to the destination IP\\Port server Example: - assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcConnect() - Note that: you may need to connect multiple times to get succeffull connection if the server close the connection by sending RST signal. Also, timing of connect is crucial, sometimes server closes the connection if the client try to connect in wrong state (from server prospective) Dependency: Can't be called before Bind() API Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | MinLength | Maxlength |\n|---|---|---|---|---|\n| DestinationIP | int[] | uint32 | 4 | 4 |\n| Destination ip where the client wants to connect input example: [192,168,144,220] for ipv4 ipv4 is 4 bytes while ipv6 is 16 bytes |  |  |  |  |\n| DestinationPort | int | uint16 | - | - |\n| remote port of target device input example: 52000, setting port to zero will let the network stack to choose random source port input range: 0 - 65535 Well-Known Ports (0\u20131023), Registered Ports (1024\u201349151), Dynamic or Private Ports (49152\u201365535) |  |  |  |  |\n\n\n---\n\n### Function: JoinGroup\n\n**Description:** Description: Purpose: Adds the socket to a specified multicast group to receive multicast traffic Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcJoinGroup( ) Dependency: Can be called after socket creation Result: Socket will begin receiving traffic sent to the specified multicast group Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | MinLength | Maxlength |\n|---|---|---|---|---|\n| Group | int[] | uint32 | 4 | 4 |\n| multicast group address represented as an array of length 4 (e.g., [224, 0, 0, 1] for multicast address 224.0.0.1). |  |  |  |  |\n\n\n---\n\n### Function: LeaveGroup\n\n**Description:** Description: Purpose: Removes the socket from a specified multicast group to stop receiving multicast traffic Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcLeaveGroup( ) Dependency: Should only be called after previously joining some group Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | MinLength | Maxlength |\n|---|---|---|---|---|\n| Group | int[] | uint32 | 4 | 4 |\n| multicast group address represented as an array of length 4 (e.g., [224, 0, 0, 1] for multicast address 224.0.0.1). |  |  |  |  |\n\n\n---\n\n### Function: SendOnce\n\n**Description:** Description: Purpose: To start sending data passed by \"TransmitData\" object Once Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcSendOnce() Dependency: Should be called after establishing a connection using 'Connect' API and setting the data to send by calling  exu.mod . .objTransmitData().afcSet(\"Data_to_send\");\n\n\n---\n\n### Function: SendPerTimer\n\n**Description:** Description: Purpose: To start sending data passed by \"TransmitData\" object after the time specified in the arg TimeMs Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcSendOnce() Dependency: Should be called after establishing a connection using 'Connect' API and setting the data to send by calling  exu.mod . .objTransmitData().afcSet(\"Data_to_send\"); Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Unit |\n|---|---|---|---|\n| TimeMs | int | uint32 | ms |\n| periodic time in ms to send the data specified by 'TransmitData' object signal |  |  |  |\n\n\n---\n\n### Function: SendPerTimerOff\n\n**Description:** Description: Purpose: Stop sending the data started by \"SendPerTimer\" API Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcSendPerTimerOff() Dependency: Should be called after SendPerTimer API to stop sending periodic messages\n\n\n---\n\n### Function: SetRetransmissionTimeout\n\n**Description:** Description: Purpose: Sets the TCP retransmission timeout value for unacknowledged packets Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcSetRetransmissionTimeout( ) Dependency: Can be called at any time, but best practice is to set before establishing a connection using 'Connect' API Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Unit |\n|---|---|---|---|\n| rto | int | uint32 | ms |\n| Retransmission timeout value in milliseconds. Default is 3000ms. |  |  |  |\n\n\n---\n\n### Function: SetUserTag\n\n**Description:** Description: The user tag is a u16 value. Set the user tag by changing the bits according to the Mask and Value.\nThe user tag is stored for each object and is copied into each message that is generated by this object.\nIt is up to the user to define the meaning of the user tag. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Mask | int | uint32 | hex |\n| Value | int | uint32 | hex |\n\n\n---\n\n### Function: TcpReconnect\n\n**Description:** Description: Purpose: Monitor that TCP connection is continuously receiving data successfully. It continously checks if the 'RstTimeout' argument exceeded to reconnect the socket again Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcTcpReconnect() Dependency: Should be called after 'Connect' API Result: You will get a response indicating whether the connection is established again Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Unit |\n|---|---|---|---|\n| Activate | boolean | bool |  |\n| boolean to activate or deactivate tcp reconnect feature |  |  |  |\n| WarningTimeout | int | uint16 | ms |\n| The allowed time between any two consecutive received packets before raising missed data warning. |  |  |  |\n| RstTimeout | int | uint16 | ms |\n| The maximum allowed time between any two consecutive received packets. After this time Castle will reset the TCP connection |  |  |  |\n\n\n---\n\n### Function: TcpRst\n\n**Description:** Description: Purpose: Reset Tcp Connection Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afcTcpRst() Dependency: Should be used (when needed) after establishing a connection using 'Connect' API\n\n\n---\n\n### Function: _Init\n\n**Description:** Description: Purpose: Initialize the Ethernet Socket Example: assume the EthernetSocket obj is called 'EthernetSocket' and the module name is modTS then you can use it as follow: exu.modTS().EthernetSocket().afc_Init(); Dependency: - Should be called as the first API in this module (i.e before calling bind and connect APIs, ((when needed))) - Note that: Based on the current implementation, if you use only one EthernetSocket (castle act as one client with one defined ip and port), then you don't have to call this API, its already called from FW but if you have array of EthernetSockets for example and castle will simulate multiple clients then you have to call this API per each EthernetSocket object\n\n\n---\n\n### Message: GeneralMessage\n\n**Description:** Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | utf8 |\n\n\n---\n\n### Message: TestTcpConnection\n\n**Description:** Description: Result of the TCP connection check Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| ConnectionEstablished | boolean | bool |\n| ConnectionStatus | int | uint8 |\n\n\n---\n\n### Object: TransmitData\n\n**Parameters:**\n\n| Name | Interface | Type | EncodedType | Offset | Scale | Format | Bytecount | ElasticLength | Mutable |\n|---|---|---|---|---|---|---|---|---|---|\n| TransmitData | _Signal | Signal | byte | 0 | 1 | raw | 51200 | true | false |\n\n\n---\n\n### Object: ReceivedData\n\n**Parameters:**\n\n| Name | Interface | Type | EncodedType | Offset | Scale | Format | Bytecount | ElasticLength | Mutable |\n|---|---|---|---|---|---|---|---|---|---|\n| ReceivedData | _Signal | Signal | byte | 0 | 1 | raw | 51200 | true | false |\n\n\n---\n\n### Object: TcpConnectionCount\n\n**Parameters:**\n\n| Name | Interface | Type | EncodedType | Offset | Scale | Bytecount | ElasticLength | Mutable |\n|---|---|---|---|---|---|---|---|---|\n| TcpConnectionCount | _Signal | Signal | int | 0 | 1 | 4 | false | false |\n\n\n---\n\n### Object: RemoteSignalRST\n\n**Parameters:**\n\n| Name | Interface | Type | EncodedType | Offset | Scale | Bytecount | ElasticLength | Mutable |\n|---|---|---|---|---|---|---|---|---|\n| RemoteSignalRST | _Signal | Signal | boolean | 0 | 1 | 1 | false | false |\n\n\n---\n\n### Object: RemoteSignalCLSD\n\n**Parameters:**\n\n| Name | Interface | Type | EncodedType | Offset | Scale | Bytecount | ElasticLength | Mutable |\n|---|---|---|---|---|---|---|---|---|\n| RemoteSignalCLSD | _Signal | Signal | boolean | 0 | 1 | 1 | false | false |\n\n\n---", "type": "Document"}}