{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "EthernetDoIP.md"}, "page_content": "### Function: CalculateAccessKey\n\n**Description:** Description: Purpose: Calculate a security access key based on a seed and other parameters. Example: *_ApiCalculateAccessKey(4, 4, 2, 2, 0x01, [0xDE, 0xAD, 0xBE, 0xEF]) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Default |\n|---|---|---|---|\n| SeedSize | int | uint32 |  |\n| The seed size in bytes |  |  |  |\n| KeySize | int | uint32 |  |\n| The key size in bytes |  |  |  |\n| SeedOffset | int | uint32 |  |\n| The seed offset in diag response buffer |  |  |  |\n| KeyOffset | int | uint32 |  |\n| The key offset in diag request buffer |  |  |  |\n| SecurityLevel | int | uint8 |  |\n| Security Level Number |  |  |  |\n| StaticKey | int[] | uint8 | [] |\n| To Decrypt/Encrypt Seed/Key (e.g. In AES128 Algo). Leave it empty if not needed |  |  |  |\n\n\n---\n\n### Function: ChooseBuffers\n\n**Description:** Description: Purpose: Choose internal buffers for Doip messages sent once, you can choose between Doip or diagnostic buffers Example: - if your Doip object defined in the project config.appl/ is 'EthernetIPv4DoIP' then you can call: exu.mod .EthernetIPv4DoIP().afcChooseBuffers(ItfEthernetDoIP.EnmBuffersEnum.DoIP); or afcChooseBuffers(ItfEthernetDoIP.EnmBuffersEnum.Diagnostics); - Note that 'ItfEthernetDoIP' and 'EnmBuffersEnum' are generated by Firmware so, if these names changed in a new Firmware version, you will have to change them in your java code accordingly Dependency: typically you would call this API with 'doip' option at the beginning of your test to send routing activation then call it again with 'Diagnostic' option to start sending diagnostic requests Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Buffers | BuffersEnum | int |\n| internal buffers to be used in doip communication. you can choose either doip or diagnostic buffers.\n\t\t\t\t\t\t\t\t  it changes the scope of the data you interested in, whether its diagnostic data or doip protocol dependant\n\t\t\t\t\t\t\t\t  data |  |  |\n\n\n---\n\n### Function: ChooseCyclicBuffers\n\n**Description:** Description: Purpose: Choose internal buffers for Doip messages sent cyclic, you can choose between Doip or diagnostic buffers Example: - if your Doip object defined in the project config.appl/ as 'EthernetIPv4DoIP' then you can call: exu.mod .EthernetIPv4DoIP().afcChooseCyclicBuffers(ItfEthernetDoIP.EnmBuffersEnum.DoIP); or afcChooseBuffers(ItfEthernetDoIP.EnmBuffersEnum.Diagnostics); - Note that 'ItfEthernetDoIP' and 'EnmBuffersEnum' are generated by Firmware so, if these names changed in a new Firmware version, you will have to change them in your java code accordingly Dependency: typically you would call this API with 'doip' option at the beginning of your test to send routing activation then call it again with 'Diagnostic' option to start sending diagnostic requests Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Buffers | BuffersEnum | int |\n| internal buffers to be used in doip communication. you can choose either doip or diagnostic buffers.\n\t\t\t\t\t\t\t\t\t  it changes the scope of the data you interested in, whether its diagnostic data or doip protocol dependant\n\t\t\t\t\t\t\t\t\t  data |  |  |\n\n\n---\n\n### Function: ClearDoIPBuffer\n\n**Description:** Description: Purpose: Clear DoIP buffer. If an error occured while receiving diagnostics data, clearing DoIP buffer at the end of the subseries of test case, prevents error propagation. Example: - if your Doip object defined in the project config.appl/ is 'EthernetIPv4DoIP' then you can call: exu.mod .EthernetIPv4DoIP().afcClearDoIPBuffer(); - Note that 'ItfEthernetDoIP' and 'EnmBuffersEnum' are generated by Firmware so, if these names changed in a new Firmware version, you will have to change them in your java code accordingly Dependency: typically you can call this API before sending the next diag request to ensure there is no errors\n\n\n---\n\n### Function: ConfigureDefaultTimeout\n\n**Description:** Description: Purpose: Configure default timeout for all send actions. Example: *_ApiConfigureDefaultTimeout(1000, 5000) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Unit |\n|---|---|---|---|\n| Timeout | int | uint16 | ms |\n| Timeout --> P2server in ISO doc: the maximum time to wait between a diag request and any response received after it i,e; positive , negative or, pending response. |  |  |  |\n| PendingResponseTimeout | int | uint16 | ms |\n| PendingResponseTimeout--> P2*server in ISO doc: the maximum time to wait between a pending response and any response received after it i,e; positive , negative or, pending response |  |  |  |\n\n\n---\n\n### Function: ConfigureDiag\n\n**Description:** Description: Purpose: Configure Diag Module: Enable/Disable Tp. Example: *_ApiConfigureDiag(true) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| EnableTp | boolean | bool |\n| If true, enables the Transport Protocol (TP) layer for diagnostics; if false, disables it. |  |  |\n\n\n---\n\n### Function: ConfigureFlowControlSendStMin\n\n**Description:** Description: Purpose: Configure CASTLE to overwrite STMin value received from the ECU in Flow Control Frame Example: *_ApiConfigureFlowControlSendStMin(10, UserInput) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Unit |\n|---|---|---|---|\n| FcSendStMin | int | uint8 | ms |\n| The flow control send StMin (in ms). |  |  |  |\n| SendStMinMode | SendStMinMode | int | - |\n| The mode for sending StMin. |  |  |  |\n\n\n---\n\n### Function: ConfigureNextSend_DisableTimeout\n\n**Description:** Description: Purpose: Configure disabling the timeout for the next send action. Example: *_ApiConfigureNextSend_DisableTimeout()\n\n\n---\n\n### Function: ConfigureNextSend_FirstConsecutiveDelay\n\n**Description:** Description: Purpose: Configure Castle first consecutive frame with a user defined delay time measured from the Ecu flow control signal. Example: *_ApiConfigureNextSend_FirstConsecutiveDelay(5) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Unit |\n|---|---|---|---|\n| CfDelay | int | uint8 | ms |\n| The consecutive frame delay (in ms). |  |  |  |\n\n\n---\n\n### Function: ConfigureNextSend_FlowControlData\n\n**Description:** Description: Purpose: Configure Castle next flow control frame data : receive block size and receive StMin. Example: *_ApiConfigureNextSend_FlowControlData(8, 10) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Unit |\n|---|---|---|---|\n| FcRecvBlockSize | int | uint8 |  |\n| The flow control receive block size. |  |  |  |\n| FcRecvStMin | int | uint8 | ms |\n| The flow control receive StMin (in ms). |  |  |  |\n\n\n---\n\n### Function: ConfigureNextSend_FlowControlDelay\n\n**Description:** Description: Purpose: Configure Castle flow control signal with a user defined delay time measured from the Ecu first frame. Example: *_ApiConfigureNextSend_FlowControlDelay(10) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Unit |\n|---|---|---|---|\n| FcDelay | int | uint16 | ms |\n| The flow control delay (in ms). |  |  |  |\n\n\n---\n\n### Function: ConfigureNextSend_Response\n\n**Description:** Description: Purpose: Configure what is expected as response. Example: *_ApiConfigureNextSend_Response(true, false, true) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| SuppressNegRsp | boolean | bool |\n| If true, negative responses will be suppressed. |  |  |\n| SuppressPosRsp | boolean | bool |\n| If true, positive responses will be suppressed. |  |  |\n| AllowResponsePending | boolean | bool |\n| If true, response pending is allowed. |  |  |\n\n\n---\n\n### Function: ConfigureNextSend_Retries\n\n**Description:** Description: Purpose: Configure options for automatic retry in the case where \"busy repeat\" was the response from ECU. Example: *_ApiConfigureNextSend_Retries(3, 10) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Scale | Unit |\n|---|---|---|---|---|\n| Retries | int | uint8 |  |  |\n| The number of retries to perform. |  |  |  |  |\n| PauseTime | int | uint16 | 0.2 | ms |\n| The pause time between retries (in ms). |  |  |  |  |\n\n\n---\n\n### Function: ConfigureNextSend_Timeout\n\n**Description:** Description: Purpose: Configure next timeout for all send actions Example: *_ApiConfigureNextSend_Timeout(1000, 5000) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Unit |\n|---|---|---|---|\n| Timeout | int | uint16 | ms |\n| Timeout --> P2server in ISO doc: the maximum time to wait between a diag request and any response received after it i,e; positive , negative or, pending response. |  |  |  |\n| PendingResponseTimeout | int | uint16 | ms |\n| PendingResponseTimeout--> P2*server in ISO doc: the maximum time to wait between a pending response and any response received after it i,e; positive , negative or, pending response |  |  |  |\n\n\n---\n\n### Function: ConfigureNextSend_Type\n\n**Description:** Description: Purpose: Send a diagnostic request. If a response is received, store it in the internal buffer and generate a logging message Example: *_ApiConfigureNextSend_Type(true) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| AsFunctional | boolean | bool |\n| If true, the request will be sent as a functional request. If false, it will be sent as a physical request. |  |  |\n\n\n---\n\n### Function: ConfigureUnexpectedReceive\n\n**Description:** Description: Purpose: Configure disabling/enabling the unexpected receive if no send action was made. Example: *_ApiConfigureUnexpectedReceive(true) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| AllowUnexpectedReceiveWarning | boolean | bool |\n| If true, unexpected receive warning is allowed. |  |  |\n\n\n---\n\n### Function: Configure_OnTestResponseFailedLogResponseAsError\n\n**Description:** Description: Purpose: When enabled, and TestResponse fails, the response will be logged as an error. Example: *_ApiConfigure_OnTestResponseFailedLogResponseAsError(true) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Enable | boolean | bool |\n| Enable or disable logging the response as an error when TestResponse fails. |  |  |\n\n\n---\n\n### Function: CopyRequestBitsToProcUnitVariable\n\n**Description:** Description: Purpose: Copy a bit sequence from the current request to a variable in the procunit. Example: *_ApiCopyRequestBitsToProcUnitVariable(2, 4, 8, false, true) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| VariableIndex | int | uint8 |\n| The index of the proc unit variable to copy the request bits to. |  |  |\n| StartBit | int | uint16 |\n| The starting bit position in the current request data from which to copy. |  |  |\n| BitLength | int | uint16 |\n| The number of bits to copy from the request data. |  |  |\n| ByteOrderBigEndian | boolean | bool |\n| Specifies the byte order (true for big-endian, false for little-endian) for interpreting the bits. |  |  |\n| AsSignedValue | boolean | bool |\n| Specifies if the copied bits should be interpreted as a signed value (true) or unsigned (false). |  |  |\n\n\n---\n\n### Function: CopyRequestLengthToProcUnitVariable\n\n**Description:** Description: Purpose: Copy the length of the current request to a variable in the procunit. Example: *_ApiCopyRequestLengthToProcUnitVariable(2) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| VariableIndex | int | uint8 |\n| The index of the proc unit variable where the current request length will be copied. |  |  |\n\n\n---\n\n### Function: CopyRequestToProcUnitVariable\n\n**Description:** Description: Purpose: Copy a part of the current request to a variable in the procunit. Example: *_ApiCopyRequestToProcUnitVariable(2, 1, 3, false) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| VariableIndex | int | uint8 |\n| The index of the proc unit variable to copy the request data to. |  |  |\n| Offset | int | uint8 |\n| The starting offset in the current request data from which to copy. |  |  |\n| ByteLength | int | uint8 |\n| The number of bytes to copy from the request data. |  |  |\n| BigEndian | boolean | bool |\n| Specifies if the copied data should be interpreted as big-endian (true) or little-endian (false). |  |  |\n\n\n---\n\n### Function: CopyResponseBitsToProcUnitVariable\n\n**Description:** Description: Purpose: Copy a bit sequence from the last received response to a variable in the procunit. Example: *_ApiCopyResponseBitsToProcUnitVariable(1, 8, 16, true, false) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| VariableIndex | int | uint8 |\n| The index of the proc unit variable to copy the response bits to. |  |  |\n| StartBit | int | uint16 |\n| The starting bit position in the received response data from which to copy. |  |  |\n| BitLength | int | uint16 |\n| The number of bits to copy from the response data. |  |  |\n| ByteOrderBigEndian | boolean | bool |\n| Specifies the byte order (true for big-endian, false for little-endian) for interpreting the bits. |  |  |\n| AsSignedValue | boolean | bool |\n| Specifies if the copied bits should be interpreted as a signed value (true) or unsigned (false). |  |  |\n\n\n---\n\n### Function: CopyResponseLengthToProcUnitVariable\n\n**Description:** Description: Purpose: Copy the length of the last received response to a variable in the procunit. Example: *_ApiCopyResponseLengthToProcUnitVariable(1) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| VariableIndex | int | uint8 |\n| The index of the proc unit variable where the response length will be copied. |  |  |\n\n\n---\n\n### Function: CopyResponseToProcUnitVariable\n\n**Description:** Description: Purpose: Copy a part of the last received response to a variable in the procunit. Example: *_ApiCopyResponseToProcUnitVariable(1, 2, 4, true) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| VariableIndex | int | uint8 |\n| The index of the proc unit variable to copy the response data to. |  |  |\n| Offset | int | uint8 |\n| The starting offset in the received response data from which to copy. |  |  |\n| ByteLength | int | uint8 |\n| The number of bytes to copy from the response data. |  |  |\n| BigEndian | boolean | bool |\n| Specifies if the copied data should be interpreted as big-endian (true) or little-endian (false). |  |  |\n\n\n---\n\n### Function: EnablePadding\n\n**Description:** Description: Purpose: Enable or disable padding for diagnostic messages. Padding is enabled by default. Example: *_ApiEnablePadding(false) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Enable | boolean | bool |\n| If true, enables padding for diagnostic messages; if false, disables padding. Padding is enabled by default. |  |  |\n\n\n---\n\n### Function: GetCyclicResponse\n\n**Description:** Description: Purpose: Gets the latest response received from a cyclically sent diagnostic request. Example: *_ApiGetCyclicResponse()\n\n\n---\n\n### Function: Prepare\n\n**Description:** Description: Purpose: Prepare the request to be send. Example: *_ApiPrepare([0x10, 0x03]) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | raw |\n| The data to prepare for sending. |  |  |  |\n\n\n---\n\n### Function: PrepareFromResponse\n\n**Description:** Description: Purpose: Prepare the request to be send from the previously received response. Example: *_ApiPrepareFromResponse()\n\n\n---\n\n### Function: PrepareModify\n\n**Description:** Description: Purpose: Modify the prepared request by replacing a byte sequence. Example: *_ApiPrepareModify(2, [0x01, 0x02]) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Offset | int | uint16 |  |\n| The offset where to replace the data. |  |  |  |\n| Data | int[] | uint8 | raw |\n| The data to replace with. |  |  |  |\n\n\n---\n\n### Function: PrepareModifyBits\n\n**Description:** Description: Purpose: Modify the prepared repuest by replacing a bit sequence. Example: *_ApiPrepareModifyBits(0x1234, 8, 16, true, false) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Value | long | int64 |\n| The value to set. |  |  |\n| StartBit | int | uint16 |\n| The start bit position. |  |  |\n| BitLength | int | uint16 |\n| The length of the bit sequence. |  |  |\n| ByteOrderBigEndian | boolean | bool |\n| If true, use big-endian byte order. |  |  |\n| AsSignedValue | boolean | bool |\n| If true, interpret the value as signed. |  |  |\n\n\n---\n\n### Function: PrepareModifyBitsProcUnitVariable\n\n**Description:** Description: Purpose: Modify the prepared request by replacing a bit sequence from a variable in the proc unit. Example: *_ApiPrepareModifyBitsProcUnitVariable(1, 8, 16, true, false) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| VariableIndex | int | uint8 |\n| The index of the variable in the proc unit. |  |  |\n| StartBit | int | uint16 |\n| The start bit position. |  |  |\n| BitLength | int | uint16 |\n| The length of the bit sequence. |  |  |\n| ByteOrderBigEndian | boolean | bool |\n| If true, use big-endian byte order. |  |  |\n| AsSignedValue | boolean | bool |\n| If true, interpret the value as signed. |  |  |\n\n\n---\n\n### Function: PrepareModifyFromResponsePart\n\n**Description:** Description: Purpose: Prepare the request to be send from the previously received response. Example: *_ApiPrepareModifyFromResponsePart(2, 4, 1) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| RspPartOffset | int | uint16 |\n| The offset of the response part to use. |  |  |\n| RspPartLength | int | uint16 |\n| The length of the response part to use. |  |  |\n| ReqOffset | int | uint16 |\n| The offset in the request where to insert the response part. |  |  |\n\n\n---\n\n### Function: PrepareModifyProcUnitVariable\n\n**Description:** Description: Purpose: Modify the prepared repuest by replacing a byte sequence from a variable in the proc unit. Example: *_ApiPrepareModifyProcUnitVariable(1, 2, 4, true) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| VariableIndex | int | uint8 |\n| The index of the variable in the proc unit. |  |  |\n| Offset | int | uint16 |\n| The offset where to replace the data. |  |  |\n| ByteLength | int | uint8 |\n| The length of the byte sequence to replace. |  |  |\n| ByteOrderBigEndian | boolean | bool |\n| If true, use big-endian byte order. |  |  |\n\n\n---\n\n### Function: PrepareModifyWithMask\n\n**Description:** Description: Purpose: Modify the prepared repuest by replacing a masked byte sequence. Example: *_ApiPrepareModifyWithMask(2, [0x01, 0x02], [0xFF, 0x0F]) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Offset | int | uint16 |  |\n| The offset where to replace the data. |  |  |  |\n| Data | int[] | uint8 | raw |\n| The data to replace with. |  |  |  |\n| Mask | int[] | uint8 | raw |\n| The mask to apply during replacement. |  |  |  |\n\n\n---\n\n### Function: ResetDiagRequest\n\n**Description:** Description: Purpose: Reset the diag request status to not block sending diag requests if there is no received response Example: - if your Doip object defined in the project config.appl/ is 'EthernetIPv4DoIP' then you can call: exu.mod .EthernetIPv4DoIP().afcResetDiagRequest(); - Note that 'ItfEthernetDoIP' and 'EnmBuffersEnum' are generated by Firmware so, if these names changed in a new Firmware version, you will have to change them in your java code accordingly Dependency: typically you can call this API before sending the next diag request to ensure the last diag response doesn't affect the next diag request\n\n\n---\n\n### Function: ResetTcpConnection\n\n**Description:** Description: Purpose: Reset Doip tcp connection. WARNING: when castile act as doip server, you can't use this API because its wrong to reset tcp socket in listening state Example: if your Doip object defined in the project config.appl/ is 'EthernetIPv4DoIP' then you can call: exu.mod .EthernetIPv4DoIP().afcResetTcpConnection(); - Note that 'ItfEthernetDoIP' and 'EnmBuffersEnum' are generated by Firmware so, if these names changed in a new Firmware version, you will have to change them in your java code accordingly Dependency: should be called in cases where you can normally reset a tcp socket. so, for example you can't use it if castle act as a server, waiting for client connections (listeneing state)\n\n\n---\n\n### Function: Send\n\n**Description:** Description: Purpose: Send a diagnostic request. If a response is received, store it in the internal buffer and generate a logging message Example: *_ApiSend([0x10, 0x03]) Return Messages: On Success: Logs [Log] if Send is successful On Failure: - Returns [Protocol] error if the transport protocol reported an error. - Returns [Timeout] error if the send didn't execute withing configured timeout. - Returns [SchedNotRunning] error if the scheduler is not running. Parameters: Response timeout: 60000\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | raw |\n| The diagnostic request data to be sent. |  |  |  |\n\n\n---\n\n### Function: SendCyclicStartNoRespMinDelay\n\n**Description:** Description: Purpose: Sends a diagnostic request cyclically. No response is expected from the other part. Implemented for CAN and Flexray. Not yet implemented for LIN. Example: *_ApiSendCyclicStartNoRespMinDelay([0x10, 0x03], 1000) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | raw |\n| The diagnostic request data to be sent cyclically. |  |  |  |\n| MinTime | int | uint32 |  |\n| The minimum time between cyclic sends. |  |  |  |\n\n\n---\n\n### Function: SendCyclicStartWithRespMinDelay\n\n**Description:** Description: Purpose: Sends a diagnostic request cyclically. The response can be \"get\" though the API GetCyclicResponse. Implemented for CAN and Flexray. Not yet implemented for LIN. Example: *_ApiSendCyclicStartWithRespMinDelay([0x10, 0x03], 1000) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | raw |\n| The diagnostic request data to be sent cyclically. |  |  |  |\n| MinTime | int | uint32 |  |\n| The minimum time between cyclic sends. |  |  |  |\n\n\n---\n\n### Function: SendCyclicStop\n\n**Description:** Description: Purpose: Stops the cyclically sent diagnostic request. Example: *_ApiSendCyclicStop()\n\n\n---\n\n### Function: SendPrepared\n\n**Description:** Description: Purpose: Send a diagnostic request. If a response is received, store it in the internal buffer and generate a logging message Example: *_ApiSendPrepared() Return Messages: On Success: Logs [Log] if Send is successful On Failure: - Returns [Protocol] error if the transport protocol reported an error. - Returns [Timeout] error if the send didn't execute withing configured timeout. - Returns [SchedNotRunning] error if the scheduler is not running. Response timeout: 60000\n\n\n---\n\n### Function: SetFunctionalDestinationAddress\n\n**Description:** Description: Purpose: - change functional destination address (for ECU) for diagnostic request/response. - This is part of preset doip configurations which typically set in config.appl/ file under doip options - This API allows the user to set it at runtime, before starting diag requests Example: if your Doip object defined in the project config.appl/ is 'EthernetIPv4DoIP' then you can call: - exu.mod .EthernetIPv4DoIP().afcSetFunctionalDestinationAddress( ); - for example, if you want to set source address 0x1234, convert it first to decimal format '4660' - Note that 'ItfEthernetDoIP' and 'EnmBuffersEnum' are generated by Firmware so, if these names changed in a new Firmware version, you will have to change them in your java code accordingly Dependency: typically you can call this API before sending any diag request (including routing activation request) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| FuncDstAddress | int | uint16 |\n| functional destination address in decimal format (unsigned short int data type) |  |  |\n\n\n---\n\n### Function: SetPadding\n\n**Description:** Description: Purpose: Set the padding byte used in the Tx Diagnostic Buffer. Example: *_ApiSetPadding(0x55) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Value | int | uint8 |\n| The byte value to be used for padding in the transmit diagnostic buffer. |  |  |\n\n\n---\n\n### Function: SetPhysicalDestinationAddress\n\n**Description:** Description: Purpose: Change physical destination address (for ECU) for diag request/response. This is part of preset doip configurations which typically set in config.appl/ file under doip options This API allows the user to set it at runtime, before starting diag requests Example: - if your Doip object defined in the project config.appl/ is 'EthernetIPv4DoIP' then you can call: exu.mod .EthernetIPv4DoIP().afcSetPhysicalDestinationAddress( ); - for example, if you want to set destination address 0x1234, convert it first to decimal format '4660' - Note that 'ItfEthernetDoIP' and 'EnmBuffersEnum' are generated by Firmware so, if these names changed in a new Firmware version, you will have to change them in your java code accordingly Dependency: typically you can call this API before sending any diag request (including routing activation request) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| PhysDstAddress | int | uint16 |\n| physical destination address in decimal format (unsigned short int data type) |  |  |\n\n\n---\n\n### Function: SetSourceAddress\n\n**Description:** Description: Purpose: Change source address (for castle) for diagnostic request/response. This is part of preset doip configurations which typically set in config.appl/ file under doip options This API allows the user to set it at runtime, before starting diag requests Example: - if your Doip object defined in the project config.appl/ is 'EthernetIPv4DoIP' then you can call: exu.mod .EthernetIPv4DoIP().afcSetSourceAddress( ); - for example, if you want to set source address 0x1234, convert it first to decimal format '4660' - Note that 'ItfEthernetDoIP' and 'EnmBuffersEnum' are generated by Firmware so, if these names changed in a new Firmware version, you will have to change them in your java code accordingly Dependency: typically you can call this API before sending any diag request (including routing activation request) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| SrcAddress | int | uint16 |\n| source address in decimal format (unsigned short int data type) |  |  |\n\n\n---\n\n### Function: SetUserTag\n\n**Description:** Description: The user tag is a u16 value. Set the user tag by changing the bits according to the Mask and Value.\nThe user tag is stored for each object and is copied into each message that is generated by this object.\nIt is up to the user to define the meaning of the user tag. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Mask | int | uint32 | hex |\n| Value | int | uint32 | hex |\n\n\n---\n\n### Function: TestByteSequence\n\n**Description:** Description: Purpose: Test the byte sequence in the diag response. It can also used to check on the positive or negative response without the need to check the data in the response. Example: *_ApiSend(\"10 01\") *_ApiTestByteSequence(0, [0x50, 0x01]) *_ApiSend(\"22 F1 90\") *_ApiTestByteSequence(0, [0x62, 0xF1, 0x90]) Return Messages: On Success: Logs [TestByteSequence] if the response as expected. On Failure: - Returns [NoData] error if no response is stored. - Returns [IndexOutOfBounds] error if the expected response length more than the actuall response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Offset | int | uint16 |  |\n| The offset in byte count for the sequence. |  |  |  |\n| Data | int[] | uint8 | raw |\n| Raw data that is expected in the response. |  |  |  |\n\n\n---\n\n### Function: TestByteSequenceDoesNotExist\n\n**Description:** Description: Purpose: Tests the absence of a byte sequence in response starting from the \"StartIndex\" byte position. Example: *_ApiTestByteSequenceDoesNotExist(2, 1, [0x01, 0x02]) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| StartIndex | int | uint8 |  |\n| The start index for the search. |  |  |  |\n| SearchStep | int | uint8 |  |\n| The step size for the search. |  |  |  |\n| Data | int[] | uint8 | raw |\n| Raw data that is expected to be not in the response. |  |  |  |\n\n\n---\n\n### Function: TestByteSequenceExist\n\n**Description:** Description: Purpose: Tests the existence of a byte sequence in response starting from the \"StartIndex\" byte position. Example: *_ApiTestByteSequenceExist(2, 1, [0x01, 0x02]) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| StartIndex | int | uint8 |  |\n| The start index for the search. |  |  |  |\n| SearchStep | int | uint8 |  |\n| The step size for the search. |  |  |  |\n| Data | int[] | uint8 | raw |\n| Raw data that is expected in the response. |  |  |  |\n\n\n---\n\n### Function: TestByteSequenceNotMatching\n\n**Description:** Description: Purpose: Test for a byte sequence in the response that should not match. Example: *_ApiTestByteSequenceNotMatching(2, [0x01, 0x02]) Return Messages: On Success: Logs [TestByteSequenceNotMatching] if the response not matching the expected response. On Failure: - Returns [NoData] error if no response is stored. - Returns [IndexOutOfBounds] error if the expected response length more than the actuall response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Offset | int | uint16 |  |\n| The offset in byte count for the sequence. |  |  |  |\n| Data | int[] | uint8 | raw |\n| Raw data that is expected to not be in the response. |  |  |  |\n\n\n---\n\n### Function: TestByteSequenceWithMask\n\n**Description:** Description: Purpose: Test for a byte sequence in the response with a mask. Example: *_ApiTestByteSequenceWithMask(2, [0xFF, 0x0F], [0x01, 0x02]) Return Messages: On Success: Logs [TestByteSequenceWithMask] if the response as expected. On Failure: - Returns [NoData] error if no response is stored. - Returns [IndexOutOfBounds] error if the expected response length more than the actuall response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Offset | int | uint16 |  |\n| The offset in byte count for the sequence. |  |  |  |\n| Mask | int[] | uint8 | raw |\n| Mask for the bits to test. Only bits set to true are tested. |  |  |  |\n| Data | int[] | uint8 | raw |\n| Raw data that is expected in the response. |  |  |  |\n\n\n---\n\n### Function: TestByteSequenceWithMaskDoesNotExist\n\n**Description:** Description: Purpose: Tests the absence of a byte sequence in response starting from the \"StartIndex\" byte position with a mask. Example: *_ApiTestByteSequenceWithMaskDoesNotExist(2, 1, [0x01, 0x02], [0xFF, 0x0F]) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| StartIndex | int | uint8 |  |\n| The start index for the search. |  |  |  |\n| SearchStep | int | uint8 |  |\n| The step size for the search. |  |  |  |\n| Data | int[] | uint8 | raw |\n| Raw data that is expected to be not in the response. |  |  |  |\n| Mask | int[] | uint8 | raw |\n| Mask for the bits to test. Only bits set to true are tested. |  |  |  |\n\n\n---\n\n### Function: TestByteSequenceWithMaskExist\n\n**Description:** Description: Purpose: Tests the existence of a byte sequence in response starting from the \"StartIndex\" byte position with a mask. Example: *_ApiTestByteSequenceWithMaskExist(2, 1, [0x01, 0x02], [0xFF, 0x0F]) Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| StartIndex | int | uint8 |  |\n| The start index for the search. |  |  |  |\n| SearchStep | int | uint8 |  |\n| The step size for the search. |  |  |  |\n| Data | int[] | uint8 | raw |\n| Raw data that is expected in the response. |  |  |  |\n| Mask | int[] | uint8 | raw |\n| Mask for the bits to test. Only bits set to true are tested. |  |  |  |\n\n\n---\n\n### Function: TestByteSequenceWithMaskNotMatching\n\n**Description:** Description: Purpose: Test for a byte sequence in the response that should not match, with a mask. Example: *_ApiTestByteSequenceWithMaskNotMatching(2, [0xFF, 0x0F], [0x01, 0x02]) Return Messages: On Success: Logs [TestByteSequenceWithMaskNotMatching] if the response not matching the expected response. On Failure: - Returns [NoData] error if no response is stored. - Returns [IndexOutOfBounds] error if the expected response length more than the actuall response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Offset | int | uint16 |  |\n| The offset in byte count for the sequence. |  |  |  |\n| Mask | int[] | uint8 | raw |\n| Mask for the bits to test. Only bits set to true are tested. |  |  |  |\n| Data | int[] | uint8 | raw |\n| Raw data that is expected to not be in the response. |  |  |  |\n\n\n---\n\n### Function: TestByteValueNoneOf\n\n**Description:** Description: Purpose: Test that a byte in the Diag Response is none of some given list of values. Offset: Byte Position TestValues: Byte Array with needed list of values Example: *_ApiTestByteValueNoneOf(3, [0xCC, 0xDD]) Return Messages: On Success: Logs [TestByteValueNoneOf] if the response matches the expected response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Offset | int | uint8 |  |\n| The byte position (0-indexed offset) in the diagnostic response to test. |  |  |  |\n| TestValues | int[] | uint8 | raw |\n| An array of byte values. The test passes if the byte at the specified offset does not match any value in this list. |  |  |  |\n\n\n---\n\n### Function: TestByteValueOneOf\n\n**Description:** Description: Purpose: Test that a byte in the Diag Response is one of some given list of values. Offset: Byte Position TestValues: Byte Array with needed list of values Example: *_ApiTestByteValueOneOf(3, [0xAA, 0xBB]) Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Offset | int | uint8 |  |\n| The byte position (0-indexed offset) in the diagnostic response to test. |  |  |  |\n| TestValues | int[] | uint8 | raw |\n| An array of byte values. The test passes if the byte at the specified offset matches any value in this list. |  |  |  |\n\n\n---\n\n### Function: TestResponse\n\n**Description:** Description: Purpose: Test if a response is stored. Then verify the response length is in range LengthMin .. LengthMax, inclusive. Example: *_ApiTestResponse(10, 20) Return Messages: On Success: Logs [TestResponse] if the response is as expected. On Failure: - Returns [NoData] error if no response is stored. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| LengthMin | int | uint16 |\n| Minimal valid length of the response. |  |  |\n| LengthMax | int | uint16 |\n| Maximal valid length of the response. |  |  |\n\n\n---\n\n### Function: TestResponseNotReceived\n\n**Description:** Description: Purpose: Test if no response is stored. Example: *_ApiTestResponseNotReceived() Return Messages: On Success: Logs [TestResponse] if the response is as expected. On Failure: - Returns [NoData] error if no response is stored. Response timeout: 0\n\n\n---\n\n### Function: TestUdsDtcNotPresent\n\n**Description:** Description: Purpose: The function can be used when the user sends 19 02 XX diagnostic request (Report DTC by Status mask) to the ECU and wants to check the absence of a DTC. The response will be the following: [59 02 XX [DTC_1_HighByte DTC_1_MidByte DTC_1_LowByte DTC_1_Status] ... [DTC_n_HighByte DTC_n_MidByte DTC_n_LowByte DTC_n_Status]]. If the DTC is NOT in the response, CASTLE generates 'TestUdsDtcPresence' information message with 0 byte index. If the DTC is in the list, CASTLE generates a 'TestUdsDtcPresence' error message with the byte index of the DTC in the response. Example: *_ApiTestUdsDtcNotPresent(0x123456) Return Messages: On Success: Logs [TestUdsDtcPresence] if the DTC not presenct as expected. On Failure: - Returns [NoData] error if no response is stored. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| DtcId | int | uint32 | hex |\n| The DTC ID to check for absence. |  |  |  |\n\n\n---\n\n### Function: TestUdsDtcPresent\n\n**Description:** Description: Purpose: The function can be used when the user sends 19 02 XX diagnostic request (Report DTC by Status mask) to the ECU and wants to check the presence of a DTC. The response will be the following: [59 02 XX [DTC_1_HighByte DTC_1_MidByte DTC_1_LowByte DTC_1_Status] ... [DTC_n_HighByte DTC_n_MidByte DTC_n_LowByte DTC_n_Status]]. If the DTC is in the response, CASTLE generates 'TestUdsDtcPresence' information message with the byte index of the DTC in the response. If the DTC is NOT in the list, CASTLE generates a 'TestUdsDtcPresence' error message with 0 byte index. Example: *_ApiTestUdsDtcPresent(0x123456) Return Messages: On Success: Logs [TestUdsDtcPresence] if the DTC presence as expected. On Failure: - Returns [NoData] error if no response is stored. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| DtcId | int | uint32 | hex |\n| The DTC ID to check for presence. |  |  |  |\n\n\n---\n\n### Function: TestUdsDtcStatus\n\n**Description:** Description: Purpose: The function can be used when the user sends 19 02 XX diagnostic request (Report DTC by Status mask) to the ECU and wants to check the status of a DTC. The response will be the following: [59 02 XX [DTC_1_HighByte DTC_1_MidByte DTC_1_LowByte DTC_1_Status] ... [DTC_n_HighByte DTC_n_MidByte DTC_n_LowByte DTC_n_Status]]. If the DTC is in the response AND the expected status matches the masked status byte, CASTLE generates 'TestUdsDtcStatus' information message. If the DTC is in the response AND the expected status does not match the masked status byte, CASTLE generates 'TestUdsDtcStatus' error message. If the DTC is NOT in the list, CASTLE generates a 'TestUdsDtcPresence' error message. Example: *_ApiTestUdsDtcStatus(0x123456, 0xFF, 0x01) Return Messages: On Success: Logs [TestUdsDtcPresence] if the DTC status as expected. On Failure: - Returns [NoData] error if no response is stored. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| DtcId | int | uint32 | hex |\n| The DTC ID to check for status. |  |  |  |\n| Mask | int | uint8 | hex |\n| Only the masked bits will be tested in the status byte. |  |  |  |\n| Status | int | uint8 | hex |\n| The expected status of the DTC. |  |  |  |\n\n\n---\n\n### Function: TestUdsDtcsPresentSubsetOf\n\n**Description:** Description: Purpose: The function can be used when the user sends 19 02 XX diagnostic request (Report DTC by Status mask) to the ECU and wants to check the existing DTCs are subset of a predefined list (DtcIdsAllowed). The received response must be the following: [59 02 XX [DTC_1_HighByte DTC_1_MidByte DTC_1_LowByte DTC_1_Status] ... [DTC_n_HighByte DTC_n_MidByte DTC_n_LowByte DTC_n_Status]]. It is not mandatory that the response contains all DTCs exist in the list (DtcIdsAllowed). If any DTC in the response is NOT exist in the list (DtcIdsAllowed), CASTLE generates a 'TestUdsDtcsPresentSubsetOf' error message with all present DTCs and not exist in the list. Example: *_ApiTestUdsDtcsPresentSubsetOf([0x123456, 0xABCDEF]) Return Messages: On Success: Logs [TestUdsDtcsPresentSubsetOf] if the subset dtc list as expected. On Failure: - Returns [NoData] error if no response is stored. - Returns [InvalidResponse] error if the subset is not present in the response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| DtcIdsAllowed | int[] | uint32 | hex |\n| Array of all allowed DTCs (without status mask). |  |  |  |\n\n\n---\n\n### Function: TestValueBitSequenceInRange\n\n**Description:** Description: Purpose: Test for a numerical value range, where the number is interpreted as (un)signed value. Example: *_ApiTestValueOutOfRange(true, 2, 2, true, -100, -50, 50, 100) Return Messages: On Success: Logs [TestValueInRange] if the response matches the expected response. On Failure: - Returns [NoData] error if no response is stored. - Returns [IndexOutOfBounds] error if the expected response length more than the actuall response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| StartBit | int | uint16 |\n| start bit index in the data buffer the left |  |  |\n| BitLength | int | uint16 |\n| number of bits |  |  |\n| IsLsbFirst | boolean | bool |\n| true if the start bit is the least significant |  |  |\n| AsSignedValue | boolean | bool |\n| signed value or unsigned |  |  |\n| LimitErrorMin | long | int64 |\n| Minimum value that is not yet an error |  |  |\n| LimitWarnMin | long | int64 |\n| Minimum value that is not yet a warning |  |  |\n| LimitWarnMax | long | int64 |\n| Maximum value that is not yet a warning |  |  |\n| LimitErrorMax | long | int64 |\n| Maximum value that is not yet an error |  |  |\n\n\n---\n\n### Function: TestValueBitsInRange\n\n**Description:** Description: Purpose: Test for a numerical value range, where the number is interpreted as (un)signed value. The limits values are inclusive, so if the value is equal to a boundary it counts as in range. The startbit is in case of big endian (motorola) the most significant bit, in case of little endian (intel) it is the least significant bit. 1. Startbit 7, Length 8, Big Endian 2. Startbit 8, Length 8, Little Endian 3. Startbit 31, Length 9, Big Endian 4. Startbit 48, Length 9, Little Endian If complete bytes shall be tested, see TestValueInRange. Example: *_ApiTestValueBitsInRange(true, 2, 2, true, -100, -50, 50, 100) Return Messages: On Success: Logs [TestValueInRange] if the response matches the expected response. On Failure: - Returns [NoData] error if no response is stored. - Returns [IndexOutOfBounds] error if the expected response length more than the actuall response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| StartBit | int | uint16 |\n| Big or Little Endian |  |  |\n| BitLength | int | uint16 |\n| ByteOrderBigEndian | boolean | bool |\n| AsSignedValue | boolean | bool |\n| LimitErrorMin | long | int64 |\n| Minimum value that is not yet an error |  |  |\n| LimitWarnMin | long | int64 |\n| Minimum value that is not yet a warning |  |  |\n| LimitWarnMax | long | int64 |\n| Maximum value that is not yet a warning |  |  |\n| LimitErrorMax | long | int64 |\n| Maximum value that is not yet an error |  |  |\n\n\n---\n\n### Function: TestValueBitsOutOfRange\n\n**Description:** Description: Purpose: Test for a numerical value range, where the number is interpreted as (un)signed value. The limits values are exclusive, so if the value is equal to a boundary it counts as out of range. The startbit is in case of big endian (motorola) the most significant bit, in case of little endian (intel) it is the least significant bit. 1: Startbit 7, Length 8, Big Endian 2: Startbit 8, Length 8, Little Endian 3: Startbit 31, Length 9, Big Endian 4: Startbit 48, Length 9, Little Endian Example: *_ApiTestValueBitsOutOfRange(true, 2, 2, true\t-100, -50, 50, 100) Return Messages: On Success: Logs [TestValueOutOfRange] if the response matches the expected response. On Failure: - Returns [NoData] error if no response is stored. - Returns [IndexOutOfBounds] error if the expected response length more than the actuall response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| StartBit | int | uint16 |\n| Big or Little Endian |  |  |\n| BitLength | int | uint16 |\n| ByteOrderBigEndian | boolean | bool |\n| AsSignedValue | boolean | bool |\n| LimitWarnMin | long | int64 |\n| Minimum value that is already a warning |  |  |\n| LimitErrorMin | long | int64 |\n| Minimum value that is already an error |  |  |\n| LimitErrorMax | long | int64 |\n| Maximum value that is already an error |  |  |\n| LimitWarnMax | long | int64 |\n| Maximum value that is already a warning |  |  |\n\n\n---\n\n### Function: TestValueInRange\n\n**Description:** Description: Purpose: Test for a numerical value range, where the number is interpreted as signed value or either 8, 16, 24 or 32 bit. The byte order can be configured. Example: *_ApiTestValueInRange(true, 2, 2, true, -100, -50, 50, 100) Return Messages: On Success: Logs [TestValueInRange] if the response matches the expected response. On Failure: - Returns [NoData] error if no response is stored. - Returns [IndexOutOfBounds] error if the expected response length more than the actuall response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| ByteOrderBigEndian | boolean | bool |\n| Big or Little Endian. |  |  |\n| Offset | int | uint16 |\n| Offset in byte count. |  |  |\n| BytesCount | int | uint8 |\n| The number of bytes to include in the value. Valid values are 1 .. 4. |  |  |\n| AsSignedValue | boolean | bool |\n| If true, interpret the value as signed. |  |  |\n| LimitErrorMin | long | int64 |\n| Minimum value that is not yet an error. |  |  |\n| LimitWarnMin | long | int64 |\n| Minimum value that is not yet a warning. |  |  |\n| LimitWarnMax | long | int64 |\n| Maximum value that is not yet a warning. |  |  |\n| LimitErrorMax | long | int64 |\n| Maximum value that is not yet an error. |  |  |\n\n\n---\n\n### Function: TestValueOutOfRange\n\n**Description:** Description: Purpose: Test for a numerical value range, where the number is interpreted as (un)signed value. The limits values are exclusive, so if the value is equal to a boundary it counts as out of range. Example: *_ApiTestValueOutOfRange(true, 2, 2, true, -100, -50, 50, 100) Return Messages: On Success: Logs [TestValueInRange] if the response matches the expected response. On Failure: - Returns [NoData] error if no response is stored. - Returns [IndexOutOfBounds] error if the expected response length more than the actuall response. Parameters: Response timeout: 0\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| ByteOrderBigEndian | boolean | bool |\n| Big or Little Endian |  |  |\n| Offset | int | uint16 |\n| in byte count |  |  |\n| BytesCount | int | uint8 |\n| The number of bytes to include in the value. Valid values are 1 .. 4. |  |  |\n| AsSignedValue | boolean | bool |\n| LimitWarnMin | long | int64 |\n| Minimum value that is already a warning |  |  |\n| LimitErrorMin | long | int64 |\n| Minimum value that is already an error |  |  |\n| LimitErrorMax | long | int64 |\n| Maximum value that is already an error |  |  |\n| LimitWarnMax | long | int64 |\n| Maximum value that is already a warning |  |  |\n\n\n---\n\n### Function: TlsInit\n\n**Description:** Description: Purpose: - Initialize TLS(transport layer security) protocol. - TLS is a security protocol used widely to acheive authentication, encryption and integrity of the communicated data through network. - This API effectively allocates TLS connection and initialize it Example: - if your Doip object defined in the project config.appl/ is 'EthernetIPv4DoIP' then you can call: exu.mod .EthernetIPv4DoIP().afcTlsInit(); - Note that 'ItfEthernetDoIP' and 'EnmBuffersEnum' are generated by Firmware so, if these names changed in a new Firmware version, you will have to change them in your java code accordingly Dependency: You should call this API before sending any diag request in order to initialize TLS connection. It should also be called once at the beginning of your test Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Certificate | int[] | uint8 | ascii |\n| If castle act as a client and is not required to send its certificate (no mutual authentication) then \n\t\t\t\t\t\t\t\t\tthis argument will be empty, if server request client certificate then this argument will represent the client certificate.\n\t\t\t\t\t\t\t\t\tIn contrast, if castle act as a server it will have to send its server certificate only to the client (in mutual authentication, it will \n\t\t\t\t\t\t\t\t\treceive the client certificate too) so, this argument will represents the server certificate required in TLS handshake process.\n\t\t\t\t\t\t\t\t\tYou should not set this argument directly instead, you should use TLS library in stdlib and give it the path of the certificate in order to read it and pass it to this argument |  |  |  |\n| CertificateAuthority | int[] | uint8 | ascii |\n| This is the certificate authority 'CA' certificate which may represents the root certificate authority or \n\t\t\t\t\t\t\t\t\tchain of trusted issuers, typically required by the client to verify the server certificate in TLS handshake process \n\t\t\t\t\t\t\t\t\tYou should not set this argument directly instead, you should use TLS library in stdlib and give it the path of the certificate in order to read it and pass it to this argument \t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tNote that certificate authority 'CA' may be very long in size |  |  |  |\n| PrivateKey | int[] | uint8 | ascii |\n| In case castle is server, the server uses the private key to decrypt data sent by the client, specifically, \n\t\t\t\t\t\t\t\t\tthe pre-master secret key which is essential for generating the sessions's symmetric keys. \n\t\t\t\t\t\t\t\t\tIn case castle is client and in scenario requiring mutual authentication, the client also possesses a private key\n\t\t\t\t\t\t\t\t\tcorresponding to its client certificate. The client uses this private key to sign data, proving its identity to the server |  |  |  |\n| PrivateKeyPassword | int[] | uint8 | ascii |\n| A private key password encrypts the private key file, adding an extra layer of security.\n\t\t\t\t\t\t\t\t\tThis ensures that even if someone gains access to the private key file, they cannot use it without the password.\n\t\t\t\t\t\t\t\t\tIts optional to use by client or server |  |  |  |\n\n\n---\n\n### Message: ByteValueTestNoneOf\n\n**Description:** Description: Obtained byte value is none from the given list Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| ObtainedByteValue | int | uint8 | hex |\n| ExpectedList | int[] | uint8 | raw |\n\n\n---\n\n### Message: ByteValueTestOneOf\n\n**Description:** Description: Obtained byte value is one from the given list Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| ObtainedByteValue | int | uint8 | hex |\n| ExpectedList | int[] | uint8 | raw |\n\n\n---\n\n### Message: DoIPLog\n\n**Description:** Description: Received DoIP response Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | raw |\n| Recived Doip response. The message represents the response when using EthernetDoip_Obj.afcSend() |  |  |  |\n\n\n---\n\n### Message: GeneralMessage\n\n**Description:** Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | utf8 |\n\n\n---\n\n### Message: GetCyclicResponse\n\n**Description:** Description: Returns the latest response received from the cyclic diag request. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | raw |\n\n\n---\n\n### Message: IndexOutOfBounds\n\n**Description:** Description: A given offset or calculated offset value exceeds the length of the received response. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Offset | int | uint16 |\n| Length | int | uint16 |\n\n\n---\n\n### Message: InvalidMasklength\n\n**Description:** Description: The used mask length doesn't match the data length.\n\n\n---\n\n### Message: InvalidResponse\n\n**Description:** Description: The current response is not valid to apply this API Used only with response 59 02 xx .....\n\n\n---\n\n### Message: InvalidSearchStep\n\n**Description:** Description: The used search step is invalid.\n\n\n---\n\n### Message: Log\n\n**Description:** Description: Received response Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | raw |\n\n\n---\n\n### Message: LogAdditionBytesWithMask\n\n**Description:** Description: Log response addition bytes with offset \"Index\" Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Index | int | uint16 |  |\n| ExpectedData | int[] | uint8 | raw |\n| Data | int[] | uint8 | raw |\n| Mask | int[] | uint8 | raw |\n\n\n---\n\n### Message: LogAdditionBytesWithShortData\n\n**Description:** Description: Log response addition bytes with offset \"Index\" Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Index | int | uint16 |  |\n| ExpectedData | int[] | uint8 | raw |\n| Data | int[] | uint8 | raw |\n| ShortData | int[] | uint8 | raw |\n\n\n---\n\n### Message: MsgTooLong\n\n**Description:** Description: The received response is too large for the internal buffer.\n\n\n---\n\n### Message: NoData\n\n**Description:** Description: Data is not yet received.\n\n\n---\n\n### Message: PreparedRequest\n\n**Description:** Description: The data send out. This is generated by SendPreparedRequest Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | raw |\n\n\n---\n\n### Message: Protocol\n\n**Description:** Description: Transport layer error. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Code | int | int32 |\n\n\n---\n\n### Message: ResponsePending\n\n**Description:** Description: DUT returned response pending.\n\n\n---\n\n### Message: ResponseTooShort\n\n**Description:** Description: The received response is too Short. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Data | int[] | uint8 | raw |\n\n\n---\n\n### Message: SchedNotRunning\n\n**Description:** Description: LinMaster scheduling is not running.\n\n\n---\n\n### Message: TestByteSequence\n\n**Description:** Description: Test of a byte sequence Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| OffsetInResponse | int | uint16 |  |\n| FailIdxInData | int | uint16 |  |\n| ExpectedData | int[] | uint8 | raw |\n| ShortData | int[] | uint8 | raw |\n| Data | int[] | uint8 | raw |\n\n\n---\n\n### Message: TestByteSequenceDoesNotExist\n\n**Description:** Description: Tests the absence of a byte sequnece in diag response. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| ExpectedData | int[] | uint8 | raw |\n| Data | int[] | uint8 | raw |\n\n\n---\n\n### Message: TestByteSequenceExist\n\n**Description:** Description: Tests the existance of a byte sequnece in diag response. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| ExpectedData | int[] | uint8 | raw |\n| Data | int[] | uint8 | raw |\n\n\n---\n\n### Message: TestByteSequenceNotMatching\n\n**Description:** Description: Test of a byte sequence Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| OffsetInResponse | int | uint16 |  |\n| FailIdxInData | int | uint16 |  |\n| ExpectedData | int[] | uint8 | raw |\n| Data | int[] | uint8 | raw |\n\n\n---\n\n### Message: TestByteSequenceWithMask\n\n**Description:** Description: Patterntest schlug fehl Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| OffsetInResponse | int | uint16 |  |\n| FailIdxInData | int | uint16 |  |\n| Mask | int[] | uint8 | raw |\n| ExpectedData | int[] | uint8 | raw |\n| Data | int[] | uint8 | raw |\n\n\n---\n\n### Message: TestByteSequenceWithMaskNotMatching\n\n**Description:** Description: Patterntest schlug fehl Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| OffsetInResponse | int | uint16 |  |\n| FailIdxInData | int | uint16 |  |\n| Mask | int[] | uint8 | raw |\n| ExpectedData | int[] | uint8 | raw |\n| Data | int[] | uint8 | raw |\n\n\n---\n\n### Message: TestResponse\n\n**Description:** Description: Test if response is received and its length. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| ResponseReceived | boolean | bool |\n| Length | int | uint16 |\n\n\n---\n\n### Message: TestUdsDtcPresence\n\n**Description:** Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Dtc | int | uint32 | hex |\n| Idx | int | uint8 |  |\n\n\n---\n\n### Message: TestUdsDtcStatus\n\n**Description:** Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| Dtc | int | uint32 | hex |\n| Idx | int | uint8 |  |\n| ExpectedStatus | int | uint8 | hex |\n| Status | int | uint8 | hex |\n| Mask | int | uint8 | hex |\n\n\n---\n\n### Message: TestUdsDtcsPresentSubsetOf\n\n**Description:** Description: List all DTCs which are not allowed to be present Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType | Format |\n|---|---|---|---|\n| NotAllowedDtcs | int[] | uint32 | hex |\n\n\n---\n\n### Message: TestValueBitsInRange\n\n**Description:** Description: Result of the range test Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| StartBit | int | uint16 |\n| BitLength | int | uint16 |\n| ByteOrderBigEndian | boolean | bool |\n| Big or Little Endian |  |  |\n| AsSignedValue | boolean | bool |\n| LimitErrorMin | long | int64 |\n| LimitWarnMin | long | int64 |\n| Value | long | int64 |\n| LimitWarnMax | long | int64 |\n| LimitErrorMax | long | int64 |\n\n\n---\n\n### Message: TestValueBitsOutOfRange\n\n**Description:** Description: Result of the range test Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| StartBit | int | uint16 |\n| BitLength | int | uint16 |\n| ByteOrderBigEndian | boolean | bool |\n| Big or Little Endian |  |  |\n| AsSignedValue | boolean | bool |\n| LimitWarnMin | long | int64 |\n| LimitErrorMin | long | int64 |\n| Value | long | int64 |\n| LimitErrorMax | long | int64 |\n| LimitWarnMax | long | int64 |\n\n\n---\n\n### Message: TestValueInRange\n\n**Description:** Description: Result of the in range test Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Offset | int | uint16 |\n| LimitErrorMin | long | int64 |\n| LimitWarnMin | long | int64 |\n| Value | long | int64 |\n| LimitWarnMax | long | int64 |\n| LimitErrorMax | long | int64 |\n\n\n---\n\n### Message: TestValueOutOfRange\n\n**Description:** Description: Result of the out of range test Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Offset | int | uint16 |\n| LimitWarnMin | long | int64 |\n| LimitErrorMin | long | int64 |\n| Value | long | int64 |\n| LimitErrorMax | long | int64 |\n| LimitWarnMax | long | int64 |\n\n\n---\n\n### Message: Timeout\n\n**Description:** Description: Timeout while waiting for the DUT.\n\n\n---\n\n### Message: TpInternalError\n\n**Description:** Description: A error condition in the TP implementation occurred. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Code | int | int32 |\n\n\n---\n\n### Message: TpUnknownError\n\n**Description:** Description: A error condition in the TP implementation occurred. Parameters:\n\n**Parameters:**\n\n| Name | Type | EncodedType |\n|---|---|---|\n| Code | int | int32 |\n\n\n---\n\n### Message: TxConf\n\n**Description:** Description: Tx Confirmation\n\n\n---\n\n### Message: UnexpectedReceive\n\n**Description:** Description: Received a frame from the DUT when it was not expected.\n\n\n---", "type": "Document"}}