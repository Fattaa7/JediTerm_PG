{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "test-scripting_hardware-apis_networking-can_best-practices_can-driverinitandshutdown.txt"}, "page_content": "[C5-CAN] Best practices\nPost date: Dec 3, 2018 1:41:12 PM\nThe majority of UPA validation tests start by sending CAN frames from CASTLE to the \nECU periodically and ends by stopping them.\nThe test steps sequence is so important to ensure proper operation and prevent fake \nbugs reporting as follows :\nSending CAN frames from castle before powering on the ECU:\nInitialize the can driver using ApiInit(EnmMode.Self_ACK)As the ecu isn't powered on\nyet the CAN bus is not fully connected hence, it won't acknowledge the reception of \nCAN frames.\nInitialize the can driver using ApiInit(EnmMode.Self_ACK)\nAs the ecu isn't powered on yet the CAN bus is not fully connected hence, it won't \nacknowledge the reception of CAN frames.\nAs the ecu isn't powered on yet the CAN bus is not fully connected hence, it won't \nacknowledge the reception of CAN frames.\nDisable error passive reporting using ConfigureRestart(EnmRestartCause.ErrorPassive,\nEnmErrorLevel.NOTHING, EnmErrorLevel.FATAL);As the receiving node ( ECU ) is \nactually off hence, this will be considered a fake error\nDisable error passive reporting using ConfigureRestart(EnmRestartCause.ErrorPassive,\nEnmErrorLevel.NOTHING, EnmErrorLevel.FATAL);\nAs the receiving node ( ECU ) is actually off hence, this will be considered a fake \nerror\nAs the receiving node ( ECU ) is actually off hence, this will be considered a fake \nerror\nSend the CAN frames\nSend the CAN frames\nPower on the ECU ( klemme 15 or 30 ) based on your project's requirments\nPower on the ECU ( klemme 15 or 30 ) based on your project's requirments\nEnable error passive reporting using ConfigureRestart(EnmRestartCause.ErrorPassive, \nEnmErrorLevel.ERROR, EnmErrorLevel.FATAL);Now the bus shall be operational as the Tx\nand Rx nodes are powered on, if an error was logged then it is a valid error and \nthis shall be investigated to ensure proper operation.\nEnable error passive reporting using ConfigureRestart(EnmRestartCause.ErrorPassive, \nEnmErrorLevel.ERROR, EnmErrorLevel.FATAL);\nNow the bus shall be operational as the Tx and Rx nodes are powered on, if an error \nwas logged then it is a valid error and this shall be investigated to ensure proper \noperation.\nNow the bus shall be operational as the Tx and Rx nodes are powered on, if an error \nwas logged then it is a valid error and this shall be investigated to ensure proper \noperation.\nSending CAN frames from castle after powering on the ECU:\nInitialize the can driver using ApiInit(EnmMode.NORMAL)As the ecu powered on it \nshall acknowledge the reception of any CAN frames sent by CASTLE.\nInitialize the can driver using ApiInit(EnmMode.NORMAL)\nAs the ecu powered on it shall acknowledge the reception of any CAN frames sent by \nCASTLE.\nAs the ecu powered on it shall acknowledge the reception of any CAN frames sent by \nCASTLE.\nEnable error passive reporting using ConfigureRestart(EnmRestartCause.ErrorPassive, \nEnmErrorLevel.ERROR, EnmErrorLevel.FATAL);Now the bus shall be operational as the Tx\nand Rx nodes are powered on, if an error was logged then it is a valid error and \nthis shall be investigated to ensure proper operation.\nEnable error passive reporting using ConfigureRestart(EnmRestartCause.ErrorPassive, \nEnmErrorLevel.ERROR, EnmErrorLevel.FATAL);\nNow the bus shall be operational as the Tx and Rx nodes are powered on, if an error \nwas logged then it is a valid error and this shall be investigated to ensure proper \noperation.\nNow the bus shall be operational as the Tx and Rx nodes are powered on, if an error \nwas logged then it is a valid error and this shall be investigated to ensure proper \noperation.\nSend the CAN frames\nSend the CAN frames\nStopping the transmission of periodic CAN frames at the end of test:\nThere are two ways to implement this\nFor each CAN frame use ApiSendPerTimerOff()Too many java calls and coding lines\nFor each CAN frame use ApiSendPerTimerOff()\nToo many java calls and coding lines\nToo many java calls and coding lines\nUse ApiShutDown()N.B: This API disables the CAN driver completely so, it is a must \nto call APIinit(EnmeMode.self_ack or Normal) in the init sequence mentioned \nearlier.Disable error passive reporting using \nConfigureRestart(EnmRestartCause.ErrorPassive, EnmErrorLevel.NOTHING, \nEnmErrorLevel.FATAL);As the receiving node ( ECU ) is actually off hence, this will \nbe considered a fake error\nUse ApiShutDown()\nN.B: This API disables the CAN driver completely so, it is a must to call \nAPIinit(EnmeMode.self_ack or Normal) in the init sequence mentioned earlier.\nN.B: This API disables the CAN driver completely so, it is a must to call \nAPIinit(EnmeMode.self_ack or Normal) in the init sequence mentioned earlier.\nDisable error passive reporting using ConfigureRestart(EnmRestartCause.ErrorPassive,\nEnmErrorLevel.NOTHING, EnmErrorLevel.FATAL);As the receiving node ( ECU ) is \nactually off hence, this will be considered a fake error\nDisable error passive reporting using ConfigureRestart(EnmRestartCause.ErrorPassive,\nEnmErrorLevel.NOTHING, EnmErrorLevel.FATAL);\nAs the receiving node ( ECU ) is actually off hence, this will be considered a fake \nerror\nAs the receiving node ( ECU ) is actually off hence, this will be considered a fake \nerror", "type": "Document"}}