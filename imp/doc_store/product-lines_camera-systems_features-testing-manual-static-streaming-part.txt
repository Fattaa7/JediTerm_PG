{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "product-lines_camera-systems_features-testing-manual-static-streaming-part.txt"}, "page_content": "SVS Features Testing Manual (Static Streaming Part)\nIn this article, we will go through the process of streaming a static image to an \nSVS ECU\nSetting up the SVS testing environment\nIf you are working on a fusion project, and it is running on a two PIM solution, you\nneed to plug them both into a Castle 5 housing.Normally, in most fusion projects, \nthe lower inserted PIM should be the TS module (usually for Comm, Diagnostics, and \nUPA applications).Upper inserted PIM module should be the VD module (usually for SVS\nvalidation).Plug the ECU video harness into the corresponding four streaming ports \nof the SVS PIP.Launch your project`s CTE.Power on the ECU and send all necessary \ncommunication frames to make the ECU request an input view from SVS cams.It is \npreferred to embed the past action in Turn_System_On CTE API.Observe the four leds \nlying above the four serializers in the PIP.The four leds should be switched on when\nthe ECU is up and running.\nIf you are working on a fusion project, and it is running on a two PIM solution, you\nneed to plug them both into a Castle 5 housing.\nIf you are working on a fusion project, and it is running on a two PIM solution, you\nneed to plug them both into a Castle 5 housing.\nNormally, in most fusion projects, the lower inserted PIM should be the TS module \n(usually for Comm, Diagnostics, and UPA applications).\nNormally, in most fusion projects, the lower inserted PIM should be the TS module \n(usually for Comm, Diagnostics, and UPA applications).\nUpper inserted PIM module should be the VD module (usually for SVS validation).\nUpper inserted PIM module should be the VD module (usually for SVS validation).\nPlug the ECU video harness into the corresponding four streaming ports of the SVS \nPIP.\nPlug the ECU video harness into the corresponding four streaming ports of the SVS \nPIP.\nLaunch your project`s CTE.\nLaunch your project`s CTE.\nPower on the ECU and send all necessary communication frames to make the ECU request\nan input view from SVS cams.\nPower on the ECU and send all necessary communication frames to make the ECU request\nan input view from SVS cams.\nIt is preferred to embed the past action in Turn_System_On CTE API.\nIt is preferred to embed the past action in Turn_System_On CTE API.\nObserve the four leds lying above the four serializers in the PIP.\nObserve the four leds lying above the four serializers in the PIP.\nThe four leds should be switched on when the ECU is up and running.\nThe four leds should be switched on when the ECU is up and running.\nThe concept behind switching on the streaming leds lies in the POC functionality.POC\n(Power on Chip) allows the Cameras (simulated by Castle 5 now) to be powered over \nthe LVDS line.Castle 5 PIP must simulate the POC circuitry located in the SVS \ncameras to mimic the behavior of being powered on by ECU.Normally, SVS ECUs check \nfor the presence and operation of SVS cameras by sensing the current drawn in the \nLVDS lines.Hence, having a load resistance / coils at the PIP side is a must for \nenabling the Stream feature.\nThe concept behind switching on the streaming leds lies in the POC functionality.\nThe concept behind switching on the streaming leds lies in the POC functionality.\nPOC (Power on Chip) allows the Cameras (simulated by Castle 5 now) to be powered \nover the LVDS line.\nPOC (Power on Chip) allows the Cameras (simulated by Castle 5 now) to be powered \nover the LVDS line.\nCastle 5 PIP must simulate the POC circuitry located in the SVS cameras to mimic the\nbehavior of being powered on by ECU.\nCastle 5 PIP must simulate the POC circuitry located in the SVS cameras to mimic the\nbehavior of being powered on by ECU.\nNormally, SVS ECUs check for the presence and operation of SVS cameras by sensing \nthe current drawn in the LVDS lines.\nNormally, SVS ECUs check for the presence and operation of SVS cameras by sensing \nthe current drawn in the LVDS lines.\nHence, having a load resistance / coils at the PIP side is a must for enabling the \nStream feature.\nHence, having a load resistance / coils at the PIP side is a must for enabling the \nStream feature.\nAs depicted in the above image, when the ECU powers up the 4 SVS cams (simulated by \nCastle now), power is supplied to the LVDS line, forcing D LED to be switched \non.Once the four leds are switched on, your environment is successfully set up and \nready to stream views to the ECU.Now, it is aMUSTto invoke theTURN_SYSTEM_OFFAPI. \nAllowing the ECU to be switched off.The past step is verynecessary.As normally, SVS \nECUs does not accept any input view from cams if it was not provided on the start up\ntime of the ECU.\nAs depicted in the above image, when the ECU powers up the 4 SVS cams (simulated by \nCastle now), power is supplied to the LVDS line, forcing D LED to be switched on.\nAs depicted in the above image, when the ECU powers up the 4 SVS cams (simulated by \nCastle now), power is supplied to the LVDS line, forcing D LED to be switched on.\nOnce the four leds are switched on, your environment is successfully set up and \nready to stream views to the ECU.\nOnce the four leds are switched on, your environment is successfully set up and \nready to stream views to the ECU.\nNow, it is aMUSTto invoke theTURN_SYSTEM_OFFAPI. Allowing the ECU to be switched \noff.\nNow, it is aMUSTto invoke theTURN_SYSTEM_OFFAPI. Allowing the ECU to be switched \noff.\nThe past step is verynecessary.As normally, SVS ECUs does not accept any input view \nfrom cams if it was not provided on the start up time of the ECU.\nThe past step is verynecessary.As normally, SVS ECUs does not accept any input view \nfrom cams if it was not provided on the start up time of the ECU.\nTest case implementation\nFirst of all, you need to make your simulated cam started and visible :\nFirst of all, you need to make your simulated cam started and visible :\nFirst of all, you need to make your simulated cam started and visible :\nexu.modVD().objCamerasDriver().afcSetCameraStarted(EnmCameraStream.CAM_0, true);\nexu().pause(10);\nexu.modVD().objCamerasDriver().afcSetCameraVisible(EnmCameraStream.CAM_0, true);\nFor starting all of four SVS simulated cams :\nFor starting all of four SVS simulated cams :\nFor starting all of four SVS simulated cams :\nexu().modVD().objCamerasDriver().afcSetCameraStarted(EnmCameraStream.CAM_0, true);\nexu().pause(10);\nexu().modVD().objCamerasDriver().afcSetCameraStarted(EnmCameraStream.CAM_1, true);\nexu().pause(10);\nexu().modVD().objCamerasDriver().afcSetCameraStarted(EnmCameraStream.CAM_2, true);\nexu().pause(10);\nexu().modVD().objCamerasDriver().afcSetCameraStarted(EnmCameraStream.CAM_3, true);\nexu().pause(10);\nexu().modVD().objCamerasDriver().afcSetCameraVisible(EnmCameraStream.CAM_0, true);\nexu().pause(10);\nexu().modVD().objCamerasDriver().afcSetCameraVisible(EnmCameraStream.CAM_1, true);\nexu().pause(10);\nexu().modVD().objCamerasDriver().afcSetCameraVisible(EnmCameraStream.CAM_2, true);\nexu().pause(10);\nexu().modVD().objCamerasDriver().afcSetCameraVisible(EnmCameraStream.CAM_3, true);\nexu().pause(10);\nThen, you need to Load a frame to the Camera`s buffer with the load API :\nThen, you need to Load a frame to the Camera`s buffer with the load API :\nThen, you need to Load a frame to the Camera`s buffer with the load API :\nLoadFrame loadFrame_01 = new LoadFrame(EnmCameraFrameBuffer.CAM_FrameBuffer_0, \ncam_01.bmp);\nexu.exec(loadFrame_01);\nThe second input argument of the LoadFrame lib constructor can hold the path to the \ninput frame.E.g. LoadFrame loadFrame_01 = new \nLoadFrame(EnmCameraFrameBuffer.CAM_FrameBuffer_0, \"config/data/cam_0.bmp\");Even more\nbetter practice could be reached by naming the load frame after a specific String \nrepresenting a test case action :\nThe second input argument of the LoadFrame lib constructor can hold the path to the \ninput frame.\nThe second input argument of the LoadFrame lib constructor can hold the path to the \ninput frame.\nE.g. LoadFrame loadFrame_01 = new LoadFrame(EnmCameraFrameBuffer.CAM_FrameBuffer_0, \n\"config/data/cam_0.bmp\");\nE.g. LoadFrame loadFrame_01 = new LoadFrame(EnmCameraFrameBuffer.CAM_FrameBuffer_0, \n\"config/data/cam_0.bmp\");\nEven more better practice could be reached by naming the load frame after a specific\nString representing a test case action :\nEven more better practice could be reached by naming the load frame after a specific\nString representing a test case action :\npublic void LoadFrame_01 (String d1, String d2) {\nLoadFrame loadFrame_01 = new LoadFrame(EnmCameraFrameBuffer.CAM_FrameBuffer_0, \nRelease_path+d1+\"\\\\\"+d2+\".bmp\"));\nexu.exec(loadFrame_01);\n}\nHere is a sample frame that you can use to load to the Load Frame Buffer \n:https://drive.google.com/file/d/1Xj2TJ3CivZ_jm9y7-ZGQPg6_zXEslRMm/view?usp=sharing\nHere is a sample frame that you can use to load to the Load Frame Buffer :\nHere is a sample frame that you can use to load to the Load Frame Buffer :\nhttps://drive.google.com/file/d/1Xj2TJ3CivZ_jm9y7-ZGQPg6_zXEslRMm/view?usp=sharing\nhttps://drive.google.com/file/d/1Xj2TJ3CivZ_jm9y7-ZGQPg6_zXEslRMm/view?usp=sharing\nIt is very important to be noted that you cannot stream any arbitrary image to the \nECU.Only the images that comply with the ECU input video requirements can be \ncaptured and recognized by ECU.You can validate or create a streaming image by one \nof the following means :Contact the ECU SOC development team to hand over all valid \nimages to be streamed to the ECU.Create an image your self by running the proper \nfilters / algorithms on any arbitrary image to convert it to the accepted ECU \nformat.Then, bind the buffer to the simulated camera :\nIt is very important to be noted that you cannot stream any arbitrary image to the \nECU.\nIt is very important to be noted that you cannot stream any arbitrary image to the \nECU.\nOnly the images that comply with the ECU input video requirements can be captured \nand recognized by ECU.\nOnly the images that comply with the ECU input video requirements can be captured \nand recognized by ECU.\nYou can validate or create a streaming image by one of the following means :Contact \nthe ECU SOC development team to hand over all valid images to be streamed to the \nECU.Create an image your self by running the proper filters / algorithms on any \narbitrary image to convert it to the accepted ECU format.\nYou can validate or create a streaming image by one of the following means :\nContact the ECU SOC development team to hand over all valid images to be streamed to\nthe ECU.\nContact the ECU SOC development team to hand over all valid images to be streamed to\nthe ECU.\nCreate an image your self by running the proper filters / algorithms on any \narbitrary image to convert it to the accepted ECU format.\nCreate an image your self by running the proper filters / algorithms on any \narbitrary image to convert it to the accepted ECU format.\nThen, bind the buffer to the simulated camera :\nThen, bind the buffer to the simulated camera :\nexu.modVD().objCamerasDriver().afcLinkCamera(EnmCameraStream.CAM_0, \nEnmCameraFrameBuffer.CAM_FrameBuffer_0);\nNow, you should validate the streamed view to the ECU.This can be realized by either\none of the following ways :Connect the output video stream of the ECU to Epiphane \nvideo capture tool (STZ) and observe the output.Connect the output video stream of \nthe ECU to the capture video input port of Castle 5 and perform a capture / store \noperation.Please refer to thisarticlefor more info about the Capture / Store \nfeature.\nNow, you should validate the streamed view to the ECU.\nNow, you should validate the streamed view to the ECU.\nThis can be realized by either one of the following ways :Connect the output video \nstream of the ECU to Epiphane video capture tool (STZ) and observe the \noutput.Connect the output video stream of the ECU to the capture video input port of\nCastle 5 and perform a capture / store operation.Please refer to thisarticlefor more\ninfo about the Capture / Store feature.\nThis can be realized by either one of the following ways :\nConnect the output video stream of the ECU to Epiphane video capture tool (STZ) and \nobserve the output.\nConnect the output video stream of the ECU to Epiphane video capture tool (STZ) and \nobserve the output.\nConnect the output video stream of the ECU to the capture video input port of Castle\n5 and perform a capture / store operation.\nConnect the output video stream of the ECU to the capture video input port of Castle\n5 and perform a capture / store operation.\nPlease refer to thisarticlefor more info about the Capture / Store feature.\nPlease refer to thisarticlefor more info about the Capture / Store feature.", "type": "Document"}}