{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "tools_third-party-tools_java_javaunittestcodecoverage.txt"}, "page_content": "Java unit test code coverage\nPost date: Sep 27, 2017 8:35:02 AM\nIn Java we have JUnit tests, to verify correctness of code.\nThose are hosted in the plugin castle.testenv.application.test\nThey can be run manually and they are run on every commit on Jenkins.\nOne measurement for unit tests is the code coverage.\nIt gives information about how many and which exact lines/branches are being run \nduring those unit tests.\nThis does not show the test deepth. But it shows those parts of the code which are \ndefinitely untested.\nHence it is a good indicator, where to put more effort in creating tests.\nThe coverage is measured by the toolJaCoCo. In EclipseEclEmmais used, which \ninternally is based on JaCoCo.\n1. Manually in Eclipse\nWhile working on unit tests, you can run the tests with coverage directly in \nEclipse.\nTo do this, install EclEmma from Eclipse Marketplace and run the plugin \"Coverage as\n...\" --> JUnit Test.\nAfter such a coverage run, all source can be seen in Eclipse with colored \nhighlightning:\nA \"Coverage\" Eclipse view can give more statistics data and overview.\n2. With Gradle locally\nTo run the same coverage as it is used at the Jenkins build and for SonarQube, run \nGradle\ngradlew test\ngradlew cleanTest test // to enforce a rerun of tests\nNow open\ncastle.testenv.application.test/build/reports/jacoco/test/html/index.html\nHere you can navigate to the same details down to the source code, but from within \nthe browser:\n3. On SonarQube\nWith each run in the overnight SonarQube scan, the jacoco reports are integrated \ninto the SonarQube results.\nThe source files are annotated with the red/green vertical bars on the left side, \nindicating if a line is covered.", "type": "Document"}}