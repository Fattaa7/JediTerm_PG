{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "test-scripting_hardware-apis_networking-diag_tutorials_integratesecurityalgorithmsembeddedindlls.txt"}, "page_content": "Integrate Security Algorithms Embedded in DLLs\nPost date: Apr 4, 2019 12:38:11 PM\nBriefly speaking, Castle 5 plays the role of a Diag master (client) in most of (if \nnot all) validation projects. And the ECU represents the slave (server) node. Some \ndiag services requires security privilege to be supported. Hence, Castle has to go \nthrough a special security access process to make the ECU grant requested \nprivileges. This process includes 3 main steps :Castle requests seed from ECU.Run \nthe security access algorithm on the input seed and obtain the corresponding \nkey.Castle sends obtained key to the ECU.Please refer to thisarticlefirst for more \ninformation on Diagnostics and Security Access.Some validation projects don`t expose\nthe security access algorithm and make it encapsulated / hidden in .dll files \ninstead.In this article, we will go through the steps of integrating a security \naccess algorithm encapsulated in a dll file.Here is the overall steps to be followed\n:Castle CTE environment is setup to listen to all Diag responses logged in make \nmessages.Castle requests seed from ECU.Upon receiving the ECU response containing \nthe seed, setup CTE listener is activated. Corresponding Java handler is invoked to \ntake the input seed from the Diag response CTE make message and apply it to the dll \nand get the corresponding key.Obtained key is sent to ECUFirst of all, we will build\na wrapper c module to call the dll within CTE test case Java environment.\nBriefly speaking, Castle 5 plays the role of a Diag master (client) in most of (if \nnot all) validation projects. And the ECU represents the slave (server) node. Some \ndiag services requires security privilege to be supported. Hence, Castle has to go \nthrough a special security access process to make the ECU grant requested \nprivileges. This process includes 3 main steps :Castle requests seed from ECU.Run \nthe security access algorithm on the input seed and obtain the corresponding \nkey.Castle sends obtained key to the ECU.\nBriefly speaking, Castle 5 plays the role of a Diag master (client) in most of (if \nnot all) validation projects. And the ECU represents the slave (server) node. Some \ndiag services requires security privilege to be supported. Hence, Castle has to go \nthrough a special security access process to make the ECU grant requested \nprivileges. This process includes 3 main steps :\nCastle requests seed from ECU.\nCastle requests seed from ECU.\nRun the security access algorithm on the input seed and obtain the corresponding \nkey.\nRun the security access algorithm on the input seed and obtain the corresponding \nkey.\nCastle sends obtained key to the ECU.\nCastle sends obtained key to the ECU.\nPlease refer to thisarticlefirst for more information on Diagnostics and Security \nAccess.\nPlease refer to thisarticlefirst for more information on Diagnostics and Security \nAccess.\nSome validation projects don`t expose the security access algorithm and make it \nencapsulated / hidden in .dll files instead.\nSome validation projects don`t expose the security access algorithm and make it \nencapsulated / hidden in .dll files instead.\nIn this article, we will go through the steps of integrating a security access \nalgorithm encapsulated in a dll file.\nIn this article, we will go through the steps of integrating a security access \nalgorithm encapsulated in a dll file.\nHere is the overall steps to be followed :Castle CTE environment is setup to listen \nto all Diag responses logged in make messages.Castle requests seed from ECU.Upon \nreceiving the ECU response containing the seed, setup CTE listener is activated. \nCorresponding Java handler is invoked to take the input seed from the Diag response \nCTE make message and apply it to the dll and get the corresponding key.Obtained key \nis sent to ECU\nHere is the overall steps to be followed :\nCastle CTE environment is setup to listen to all Diag responses logged in make \nmessages.\nCastle CTE environment is setup to listen to all Diag responses logged in make \nmessages.\nCastle requests seed from ECU.\nCastle requests seed from ECU.\nUpon receiving the ECU response containing the seed, setup CTE listener is \nactivated. Corresponding Java handler is invoked to take the input seed from the \nDiag response CTE make message and apply it to the dll and get the corresponding \nkey.\nUpon receiving the ECU response containing the seed, setup CTE listener is \nactivated. Corresponding Java handler is invoked to take the input seed from the \nDiag response CTE make message and apply it to the dll and get the corresponding \nkey.\nObtained key is sent to ECU\nObtained key is sent to ECU\nFirst of all, we will build a wrapper c module to call the dll within CTE test case \nJava environment.\nFirst of all, we will build a wrapper c module to call the dll within CTE test case \nJava environment.\nWhy can`t we call the dll in Java directly ?Because - in most cases - the dll is a \n32-bit windows application, while our CTE Java environment is 64-bit.\nWhy can`t we call the dll in Java directly ?\nBecause - in most cases - the dll is a 32-bit windows application, while our CTE \nJava environment is 64-bit.\nBecause - in most cases - the dll is a 32-bit windows application, while our CTE \nJava environment is 64-bit.\nBecause - in most cases - the dll is a 32-bit windows application, while our CTE \nJava environment is 64-bit.\nHence, we need a 64-bit wrapper application that is compiled on our PC and could be \ncalled within CTE Java test cases.The wrapper application is a simple main.c module \n(attached example at the end of the article) that takes an input seed from CTE \nenvironment and applies this seed as an input to the dll.Main.c module is to be \ncompiled and linked with the dll.It is preferred to setup Cygwin first and add it to\nyour environment variables Path as we will use it to compile and link our .c \nwrapper. It is okay if you have alternative environment to compile c projects.\nHence, we need a 64-bit wrapper application that is compiled on our PC and could be \ncalled within CTE Java test cases.\nHence, we need a 64-bit wrapper application that is compiled on our PC and could be \ncalled within CTE Java test cases.\nThe wrapper application is a simple main.c module (attached example at the end of \nthe article) that takes an input seed from CTE environment and applies this seed as \nan input to the dll.\nThe wrapper application is a simple main.c module (attached example at the end of \nthe article) that takes an input seed from CTE environment and applies this seed as \nan input to the dll.\nMain.c module is to be compiled and linked with the dll.\nMain.c module is to be compiled and linked with the dll.\nIt is preferred to setup Cygwin first and add it to your environment variables Path \nas we will use it to compile and link our .c wrapper. It is okay if you have \nalternative environment to compile c projects.\nIt is preferred to setup Cygwin first and add it to your environment variables Path \nas we will use it to compile and link our .c wrapper. It is okay if you have \nalternative environment to compile c projects.\nIf you choose to work on Cygwin, it is mandatory to setup this tool on the tester`s \nmachine. Not just yours.\nIf you choose to work on Cygwin, it is mandatory to setup this tool on the tester`s \nmachine. Not just yours.\nAlso, it is mandatory to add Cygwin to the Environment VariablesOr you can add \ncygwin1.dll file (attached below) to the same path that the .exe file is exist.Open \nup Cygwin Terminal, compile Main.c and link it to the given dll with this command :\nAlso, it is mandatory to add Cygwin to the Environment Variables\nAlso, it is mandatory to add Cygwin to the Environment Variables\nOr you can add cygwin1.dll file (attached below) to the same path that the .exe file\nis exist.\nOr you can add cygwin1.dll file (attached below) to the same path that the .exe file\nis exist.\nOpen up Cygwin Terminal, compile Main.c and link it to the given dll with this \ncommand :\nOpen up Cygwin Terminal, compile Main.c and link it to the given dll with this \ncommand :\ngcc main.c -o security_algo.exe -L. -lsecurity_dll_file_name\ngcc main.c -o security_algo.exe -L. -lsecurity_dll_file_name\nsecurity_algo.exe is the output executable from compilation.security_algo.exe is \nalso the executable to be invoked with the seed within the test case.\nsecurity_algo.exe is the output executable from compilation.\nsecurity_algo.exe is the output executable from compilation.\nsecurity_algo.exe is also the executable to be invoked with the seed within the test\ncase.\nsecurity_algo.exe is also the executable to be invoked with the seed within the test\ncase.\nNow, in the following part, we will configure the CTE environment to listen to Diag \nresponses logged in make messages.\nNow, in the following part, we will configure the CTE environment to listen to Diag \nresponses logged in make messages.\nDeclare a new listening consumer in CteSetup.java :Add the following line to \nconfigureExu method in CteSetup to register a listener event in CTE environmentThe \nlistener is to act only on objCanDiag make messages.DiagListener Java class is to \nimplement ICteEventListener generic CTE event class.\nDeclare a new listening consumer in CteSetup.java :\nDeclare a new listening consumer in CteSetup.java :\nAdd the following line to configureExu method in CteSetup to register a listener \nevent in CTE environment\nAdd the following line to configureExu method in CteSetup to register a listener \nevent in CTE environment\nThe listener is to act only on objCanDiag make messages.\nThe listener is to act only on objCanDiag make messages.\nDiagListener Java class is to implement ICteEventListener generic CTE event class.\nDiagListener Java class is to implement ICteEventListener generic CTE event class.\npublicclassDiagListenerimplementsICteEventListener {@Overridepublicvoid \ncteEvent(CteEventType type,Stringname,Objectparam) {   Consumer<IModuleMessage> \nlisteningConsumer = CteSetup.DiaglisteningConsumer;if(listeningConsumer ==null) \n{return;   }if(type == CteEventType.Message && name.equals(\"msgLog\")) {    \nIModuleMessage msg = (IModuleMessage) param;    listeningConsumer.accept(msg);   }  \n}}\nAdd the following methods to CteSetup for registering / un-registering the listener \nevent with the handler :\nAdd the following methods to CteSetup for registering / un-registering the listener \nevent with the handler :\nAdd the following methods to CteSetup for registering / un-registering the listener \nevent with the handler :\npublicstaticvoid addDiagListeningConsumer( Consumer<IModuleMessage> \nlisteningConsumer ) {          DiaglisteningConsumer = listeningConsumer;      \n}publicstaticvoid removeDiagListeningConsumer( Consumer<IModuleMessage> \nlisteningConsumer ) {           DiaglisteningConsumer =null;      }\nRegister the listener with the handler (listenerHandler) with the following call in \nthe security testing lib.listenerHandler is to be executed on every objCanDiag make \nmessage logged in CTE.listenerHandler method is to do the following steps :parse the\ncontent of the Diag response make message and extract the seed.Call \nsecurity_algo.exe with the seed value and obtain the key.Send the obtained key to \nthe ECU in a normal Diag send.Place listenerHandler method in a new Java lib \n(KeyGenerationLib.java here).\nRegister the listener with the handler (listenerHandler) with the following call in \nthe security testing lib.\nRegister the listener with the handler (listenerHandler) with the following call in \nthe security testing lib.\nlistenerHandler is to be executed on every objCanDiag make message logged in CTE.\nlistenerHandler is to be executed on every objCanDiag make message logged in CTE.\nlistenerHandler method is to do the following steps :parse the content of the Diag \nresponse make message and extract the seed.Call security_algo.exe with the seed \nvalue and obtain the key.Send the obtained key to the ECU in a normal Diag send.\nlistenerHandler method is to do the following steps :\nparse the content of the Diag response make message and extract the seed.\nparse the content of the Diag response make message and extract the seed.\nCall security_algo.exe with the seed value and obtain the key.\nCall security_algo.exe with the seed value and obtain the key.\nSend the obtained key to the ECU in a normal Diag send.\nSend the obtained key to the ECU in a normal Diag send.\nPlace listenerHandler method in a new Java lib (KeyGenerationLib.java here).\nPlace listenerHandler method in a new Java lib (KeyGenerationLib.java here).\nstaticString msgContent = new String();staticString[] Key_outputData = new \nString[8];\nstaticString[] recieved_seed = new String[8];\npublicvoid listenerHandler(IModuleMessage msg) {   msgContent = \nmsg.getValue(\"Data\").getFormattedValue();if(msgContent.contains(\"[ 67 11\")) {    \nrecieved_seed = msgContent.split(\" \");    ExternCmd cmd \n=newExternCmd(ArrayUtil.asList(System.getProperty(\"user.dir\") + \n\"\\\\prj\\\\src\\\\prj\\\\lib\\\\security_algo.exe \", recieved_seed[3],      recieved_seed[4],\nrecieved_seed[5], recieved_seed[6], recieved_seed[7], recieved_seed[8],      \nrecieved_seed[9], recieved_seed[10]), 10000);try{     Runner runner = \ncmd.run(newFile(System.getProperty(\"user.dir\") + \"\\\\prj\\\\src\\\\prj\\\\lib\"));     \nrunner.joinAll();Stringoutput = runner.getOutput();     Key_outputData = \noutput.split(\" \");     }catch(RuntimeExceptione) {     ExceptionUtil.ignore(e);     \ne.printStackTrace();System.out.println(\"Exception Occured While trying to generate \nthe key\");    }catch(InterruptedExceptione) {Thread.currentThread().interrupt();    \n}       }   }\nNow, Key_outputData static array holds the obtained key values.This array is to be \naccessed from any test case lib to send the data to the ECU.\nNow, Key_outputData static array holds the obtained key values.\nNow, Key_outputData static array holds the obtained key values.\nThis array is to be accessed from any test case lib to send the data to the ECU.\nThis array is to be accessed from any test case lib to send the data to the ECU.\nexu.modTS().objCanDiag().afcSend(\"27 12 \" + KeyGenerationLib.Key_outputData[0] + \" \"\n+ KeyGenerationLib.Key_outputData[1] + \" \"     + KeyGenerationLib.Key_outputData[2] \n+ \" \" + KeyGenerationLib.Key_outputData[3] + \" \" + \nKeyGenerationLib.Key_outputData[4] + \" \" + KeyGenerationLib.Key_outputData[5]     + \n\" \" + KeyGenerationLib.Key_outputData[6] + \" \" + KeyGenerationLib.Key_outputData[7] \n+ \" \");\nExtra tips incase you faced an issue while linking the dll:\nUse a Dll viewer app ( ex :Dependancy)to confirm both the Security function \nsignature and the dll build environment ( 32bit or 64 bit )\nUse a Dll viewer app ( ex :Dependancy)to confirm both the Security function \nsignature and the dll build environment ( 32bit or 64 bit )\nIncase the dll is built with a 32bit environment as attached screenshot, you should \nchoose the most close cygwing gcc variant to link your main to the dll and add \n\"-m32\" option [ ex:i686-pc-cygwin-gccmain.c -o security_algo.exe -L. \n-lsecurity_dll_file_name -m32]\nIncase the dll is built with a 32bit environment as attached screenshot, you should \nchoose the most close cygwing gcc variant to link your main to the dll and add \n\"-m32\" option [ ex:i686-pc-cygwin-gccmain.c -o security_algo.exe -L. \n-lsecurity_dll_file_name -m32]\npublicstaticConsumer<IModuleMessage> \nDiaglisteningConsumer;exu.modTS().objCanDiag().addCteEventListener(new \nDiagListener());\npublicstaticConsumer<IModuleMessage> \nDiaglisteningConsumer;exu.modTS().objCanDiag().addCteEventListener(new \nDiagListener());\npublicstaticConsumer<IModuleMessage> DiaglisteningConsumer;\npublicstaticConsumer<IModuleMessage> DiaglisteningConsumer;\nexu.modTS().objCanDiag().addCteEventListener(new DiagListener());\nexu.modTS().objCanDiag().addCteEventListener(new DiagListener());\nCteSetup.addDiagListeningConsumer(this::listenerHandler);\nCteSetup.addDiagListeningConsumer(this::listenerHandler);\nCteSetup.addDiagListeningConsumer(this::listenerHandler);\nCteSetup.addDiagListeningConsumer(this::listenerHandler);", "type": "Document"}}