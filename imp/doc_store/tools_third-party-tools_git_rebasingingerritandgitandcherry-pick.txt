{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "tools_third-party-tools_git_rebasingingerritandgitandcherry-pick.txt"}, "page_content": "Rebasing in Gerrit and Git and Cherry-Pick\nPost date: Mar 21, 2019 10:24:21 AM\nRebasing is the action of creating modified (re-written) commits in git, to have a \ndifferent parent as before.\nGit vs Gerrit\nIn Git this can be done for a single commit or a whole branch. If the rebase is done\n(without interactive), then git searches for the common parent and moves the whole \nbranch onto the target commit.\nIn Gerrit this is always only valid for the actual change. So it is not strictly the\nequivalent to git rebase.\nAs the same word 'rebase' is used, but the behavior is different, this can lead to \nsurprising/unwanted effects.\nExample sequence:\nLocal head is 'A', i create 2 change 'B' and then 'C' and push to Gerrit.\nA <- B <- C\nMeanwhile another change X was submitted, and the result is a \"cannot merge\" message\nin Gerrit.\nSo I use Gerrit to rebase B (onto X).\nThis creates B*.\nBecause my C has some dependency on the change in B, now i want to rebase it onto \nB*. But unfortunately for some reason there is a conflict and Gerrit cannot \ncontinue. I have to do it locally.\nSo i fetch my upstream to get X, and fetch my change C.\nNow i have:\nA <- X\n\\- B <- C\nNote that I don't have B* locally at this moment. And perhaps I am not aware of it.\nI might have created new patchsets based on B*.\nIf i do now a git rebase of the change C onto the master (X), then this happens:\nGit searches for the common parent of C+X, which is A. So it takes the sequence \"B, \nC\" and rebasesbothof them onto X.\nThis creates:\nA <- X <- B** <- C*\nThe problemhere is the newly created commit B**, while i wanted only to have C being\nrebased and certainly B* to be the parent was my intention.\nIf i do now a push to gerrit, B** might be either accepted and \"overwrites\" B* \nwithout explicit notification or it is perhaps rejected by Gerrit if B* was already \nsubmitted.\nThe better way to solve this locally isgit cherry-pick.\nThis is doing the action only for a single commit.\nTo do this, i need first to get and checkout the basis for the commit. In the \nexample this is B*.\nSo i get and checkout B* (fetch from gerrit).\nThen i get C without checkout. (or it is still available)\nThen in the Eclipse git history find the commit C, and select the cherry-pick \naction.\nResolve conflict, commit, push and delete the local branch, as its name is now \nconfusing. The branch is called like the B change, but it has the C commit.", "type": "Document"}}