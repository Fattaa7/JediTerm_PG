{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "general-topics_mipi-csi-2_mipi-protocols_mipi-csi-2-2-of-2.txt"}, "page_content": "MIPI CSI-2 (2 of 2)\n2.2   Low Level Protocol:\nThe Low Level Protocol (LLP) includes the means of establishing bit level and \nbyte-level synchronization for serial data transferred between SoT (Start of \nTransmission) and EoT (End of Transmission) events and for passing data to the next \nlayer.The minimum data granularity of the LLP is one byte.The LLP also includes \nassignment of bit-value interpretation within the byte, i.e. the \u201cEndian\u201d \nassignment.The Low Level Protocol (LLP) is a byte orientated, packet based protocol \nthat supports the transport of arbitrary data using Short and Long packet \nformats.Low Level Protocol Features:Transport of arbitrary data (Payload \nindependent)8-bit word sizeSupport for up to four interleaved virtual channels on \nthe same linkSpecial packets for frame start, frame end, line start and line end \ninformationDescriptor for the type, pixel depth and format of the Application \nSpecific Payload data16-bit Checksum Code for error detectionThe following figure \ndepicts Low Level Protocol Packet Overview\nThe Low Level Protocol (LLP) includes the means of establishing bit level and \nbyte-level synchronization for serial data transferred between SoT (Start of \nTransmission) and EoT (End of Transmission) events and for passing data to the next \nlayer.\nThe Low Level Protocol (LLP) includes the means of establishing bit level and \nbyte-level synchronization for serial data transferred between SoT (Start of \nTransmission) and EoT (End of Transmission) events and for passing data to the next \nlayer.\nThe minimum data granularity of the LLP is one byte.\nThe minimum data granularity of the LLP is one byte.\nThe LLP also includes assignment of bit-value interpretation within the byte, i.e. \nthe \u201cEndian\u201d assignment.\nThe LLP also includes assignment of bit-value interpretation within the byte, i.e. \nthe \u201cEndian\u201d assignment.\nThe Low Level Protocol (LLP) is a byte orientated, packet based protocol that \nsupports the transport of arbitrary data using Short and Long packet formats.\nThe Low Level Protocol (LLP) is a byte orientated, packet based protocol that \nsupports the transport of arbitrary data using Short and Long packet formats.\nLow Level Protocol Features:Transport of arbitrary data (Payload independent)8-bit \nword sizeSupport for up to four interleaved virtual channels on the same linkSpecial\npackets for frame start, frame end, line start and line end informationDescriptor \nfor the type, pixel depth and format of the Application Specific Payload data16-bit \nChecksum Code for error detection\nLow Level Protocol Features:\nTransport of arbitrary data (Payload independent)\nTransport of arbitrary data (Payload independent)\n8-bit word size\n8-bit word size\nSupport for up to four interleaved virtual channels on the same link\nSupport for up to four interleaved virtual channels on the same link\nSpecial packets for frame start, frame end, line start and line end information\nSpecial packets for frame start, frame end, line start and line end information\nDescriptor for the type, pixel depth and format of the Application Specific Payload \ndata\nDescriptor for the type, pixel depth and format of the Application Specific Payload \ndata\n16-bit Checksum Code for error detection\n16-bit Checksum Code for error detection\nThe following figure depicts Low Level Protocol Packet Overview\nThe following figure depicts Low Level Protocol Packet Overview\nTwo packet structures are defined for low-level protocol communication: Long packets\nand Short packets.For each packet structure exit from the low power state followed \nby the Start of Transmission (SoT) sequence indicates the start of the packet.The \nEnd of Transmission (EoT) sequence followed by the low power state indicates the end\nof the packet.\nTwo packet structures are defined for low-level protocol communication: Long packets\nand Short packets.\nTwo packet structures are defined for low-level protocol communication: Long packets\nand Short packets.\nFor each packet structure exit from the low power state followed by the Start of \nTransmission (SoT) sequence indicates the start of the packet.\nFor each packet structure exit from the low power state followed by the Start of \nTransmission (SoT) sequence indicates the start of the packet.\nThe End of Transmission (EoT) sequence followed by the low power state indicates the\nend of the packet.\nThe End of Transmission (EoT) sequence followed by the low power state indicates the\nend of the packet.\n2.2.1  Low Level Protocol Long Packet Format\nThe following figure depicts the structure of the Low Level Protocol Long Packet:\nThe following figure depicts the structure of the Low Level Protocol Long Packet:\nThe following figure depicts the structure of the Low Level Protocol Long Packet:\nA Long Packet shall be identified by Data Types 0x10 to 0x37A Long Packet shall \nconsist of three elements:A 32-bit Packet Header (PH)An application specific Data \nPayload with a variable number of 8-bit data wordsA 16-bit Packet Footer (PF)The \nPacket Header is further composed of three elements:An 8-bit Data Identifier16-bit \nWord Count fieldAn 8-bit ECCThe Packet footer has one element, a 16-bit checksum.The\nData Identifier defines the Virtual Channel for the data and the Data Type for the \napplication specific payload data.The Word Count defines the number of 8-bit data \nwords in the Data Payload between the end of the Packet Header and the start of the \nPacket Footer.Neither the Packet Header nor the Packet Footer shall be included in \nthe Word Count.The Error Correction Code (ECC) byte allows single-bit errors to be \ncorrected and 2-bit errors to be detected in the packet header.This includes both \nthe data identifier value and the word count value.After the end of the Packet \nHeader the receiver reads the next Word Count * 8-bit data words of the Data \nPayload.While reading the Data Payload the receiver shall not look for any embedded \nsync codes.Therefore, there are no limitations on the value of a data word.Once the \nreceiver has read the Data Payload it reads the checksum in the Packet Footer.In the\ngeneric case, the length of the Data Payload shall be a multiple of 8-bit data \nwords.In addition, each data format may impose additional restrictions on the length\nof the payload data, e.g. multiple of four bytes.Each byte shall be transmitted \nleast significant bit first.Payload data may be transmitted in any byte order, \nrestricted only by data format requirements.Multi-byte elements such as Word Count, \nChecksum and the Short packet 16-bit Data Field shall be transmitted least \nsignificant byte first.After the EoT sequence the receiver begins looking for the \nnext SoT sequence.\nA Long Packet shall be identified by Data Types 0x10 to 0x37\nA Long Packet shall be identified by Data Types 0x10 to 0x37\nA Long Packet shall consist of three elements:A 32-bit Packet Header (PH)An \napplication specific Data Payload with a variable number of 8-bit data wordsA 16-bit\nPacket Footer (PF)\nA Long Packet shall consist of three elements:\nA 32-bit Packet Header (PH)\nA 32-bit Packet Header (PH)\nAn application specific Data Payload with a variable number of 8-bit data words\nAn application specific Data Payload with a variable number of 8-bit data words\nA 16-bit Packet Footer (PF)\nA 16-bit Packet Footer (PF)\nThe Packet Header is further composed of three elements:An 8-bit Data \nIdentifier16-bit Word Count fieldAn 8-bit ECC\nThe Packet Header is further composed of three elements:\nAn 8-bit Data Identifier\nAn 8-bit Data Identifier\n16-bit Word Count field\n16-bit Word Count field\nAn 8-bit ECC\nAn 8-bit ECC\nThe Packet footer has one element, a 16-bit checksum.\nThe Packet footer has one element, a 16-bit checksum.\nThe Data Identifier defines the Virtual Channel for the data and the Data Type for \nthe application specific payload data.\nThe Data Identifier defines the Virtual Channel for the data and the Data Type for \nthe application specific payload data.\nThe Word Count defines the number of 8-bit data words in the Data Payload between \nthe end of the Packet Header and the start of the Packet Footer.\nThe Word Count defines the number of 8-bit data words in the Data Payload between \nthe end of the Packet Header and the start of the Packet Footer.\nNeither the Packet Header nor the Packet Footer shall be included in the Word Count.\nNeither the Packet Header nor the Packet Footer shall be included in the Word Count.\nThe Error Correction Code (ECC) byte allows single-bit errors to be corrected and \n2-bit errors to be detected in the packet header.\nThe Error Correction Code (ECC) byte allows single-bit errors to be corrected and \n2-bit errors to be detected in the packet header.\nThis includes both the data identifier value and the word count value.\nThis includes both the data identifier value and the word count value.\nAfter the end of the Packet Header the receiver reads the next Word Count * 8-bit \ndata words of the Data Payload.\nAfter the end of the Packet Header the receiver reads the next Word Count * 8-bit \ndata words of the Data Payload.\nWhile reading the Data Payload the receiver shall not look for any embedded sync \ncodes.\nWhile reading the Data Payload the receiver shall not look for any embedded sync \ncodes.\nTherefore, there are no limitations on the value of a data word.\nTherefore, there are no limitations on the value of a data word.\nOnce the receiver has read the Data Payload it reads the checksum in the Packet \nFooter.\nOnce the receiver has read the Data Payload it reads the checksum in the Packet \nFooter.\nIn the generic case, the length of the Data Payload shall be a multiple of 8-bit \ndata words.\nIn the generic case, the length of the Data Payload shall be a multiple of 8-bit \ndata words.\nIn addition, each data format may impose additional restrictions on the length of \nthe payload data, e.g. multiple of four bytes.\nIn addition, each data format may impose additional restrictions on the length of \nthe payload data, e.g. multiple of four bytes.\nEach byte shall be transmitted least significant bit first.\nEach byte shall be transmitted least significant bit first.\nPayload data may be transmitted in any byte order, restricted only by data format \nrequirements.\nPayload data may be transmitted in any byte order, restricted only by data format \nrequirements.\nMulti-byte elements such as Word Count, Checksum and the Short packet 16-bit Data \nField shall be transmitted least significant byte first.\nMulti-byte elements such as Word Count, Checksum and the Short packet 16-bit Data \nField shall be transmitted least significant byte first.\nAfter the EoT sequence the receiver begins looking for the next SoT sequence.\nAfter the EoT sequence the receiver begins looking for the next SoT sequence.\n2.2.2  Low Level Protocol Short Packet Format\nThe following figure shows the structure of the Low Level Protocol Short Packet\nThe following figure shows the structure of the Low Level Protocol Short Packet\nThe following figure shows the structure of the Low Level Protocol Short Packet\nA Short Packet shall be identified by Data Types 0x00 to 0x0FA Short Packet shall \ncontain only a Packet Header; a Packet Footer shall not be present.The Word Count \nfield in the Packet Header shall be replaced by a Short Packet Data Field.For Frame \nSynchronization Data Types the Short Packet Data Field shall be the frame number.For\nLine Synchronization Data Types the Short Packet Data Field shall be the line \nnumber.\nA Short Packet shall be identified by Data Types 0x00 to 0x0F\nA Short Packet shall be identified by Data Types 0x00 to 0x0F\nA Short Packet shall contain only a Packet Header; a Packet Footer shall not be \npresent.\nA Short Packet shall contain only a Packet Header; a Packet Footer shall not be \npresent.\nThe Word Count field in the Packet Header shall be replaced by a Short Packet Data \nField.\nThe Word Count field in the Packet Header shall be replaced by a Short Packet Data \nField.\nFor Frame Synchronization Data Types the Short Packet Data Field shall be the frame \nnumber.\nFor Frame Synchronization Data Types the Short Packet Data Field shall be the frame \nnumber.\nFor Line Synchronization Data Types the Short Packet Data Field shall be the line \nnumber.\nFor Line Synchronization Data Types the Short Packet Data Field shall be the line \nnumber.\n2.2.3 Data Identifier (DI)\nThe Data Identifier byte contains the Virtual Channel Identifier (VC) value and the \nData Type (DT) value.\nThe Data Identifier byte contains the Virtual Channel Identifier (VC) value and the \nData Type (DT) value.\nThe Data Identifier byte contains the Virtual Channel Identifier (VC) value and the \nData Type (DT) value.\nThe Virtual Channel Identifier is contained in the two MS bits of the Data \nIdentifier Byte.\nThe Virtual Channel Identifier is contained in the two MS bits of the Data \nIdentifier Byte.\nThe Data Type value is contained in the six LS bits of the Data Identifier Byte.\nThe Data Type value is contained in the six LS bits of the Data Identifier Byte.\n2.2.4 Virtual Channel Identifier\nThe purpose of the Virtual Channel Identifier is to provide separate channels for \ndifferent data flows that are interleaved in the data stream.The Receiver will \nmonitor the virtual channel identifier and de-multiplex the interleaved video \nstreams to their appropriate channel.A maximum of four data streams is supported; \nvalid channel identifiers are 0 to 3.The virtual channel identifiers in the \nperipherals should be programmable to allow the host processor to control how the \ndata streams are de-multiplexed.The principle of logical channels is presented in \nthe following figure:\nThe purpose of the Virtual Channel Identifier is to provide separate channels for \ndifferent data flows that are interleaved in the data stream.\nThe purpose of the Virtual Channel Identifier is to provide separate channels for \ndifferent data flows that are interleaved in the data stream.\nThe Receiver will monitor the virtual channel identifier and de-multiplex the \ninterleaved video streams to their appropriate channel.\nThe Receiver will monitor the virtual channel identifier and de-multiplex the \ninterleaved video streams to their appropriate channel.\nA maximum of four data streams is supported; valid channel identifiers are 0 to 3.\nA maximum of four data streams is supported; valid channel identifiers are 0 to 3.\nThe virtual channel identifiers in the peripherals should be programmable to allow \nthe host processor to control how the data streams are de-multiplexed.\nThe virtual channel identifiers in the peripherals should be programmable to allow \nthe host processor to control how the data streams are de-multiplexed.\nThe principle of logical channels is presented in the following figure:\nThe principle of logical channels is presented in the following figure:\nThe following figure illustrates an example of data streams utilizing virtual \nchannel support\nThe following figure illustrates an example of data streams utilizing virtual \nchannel support\nThe following figure illustrates an example of data streams utilizing virtual \nchannel support\n2.2.5 Data Type (DT)\nThe Data Type value specifies the format and content of the payload data. A maximum \nof sixty-four data types are supported.Data type classes:\nThe Data Type value specifies the format and content of the payload data. A maximum \nof sixty-four data types are supported.\nData type classes:\nData type classes:\nSynchronization Short Packet Data Type CodesShort Packet Data Types shall be \ntransmitted using only the Short Packet format\nSynchronization Short Packet Data Type Codes\nSynchronization Short Packet Data Type Codes\nShort Packet Data Types shall be transmitted using only the Short Packet format\nShort Packet Data Types shall be transmitted using only the Short Packet format\n2.2.6 Frame Synchronization Packets\nEach image frame shall begin with a Frame Start (FS) Packet containing the Frame \nStart Code.The FS Packet shall be followed by one or more long packets containing \nimage data and zero or more short packets containing synchronization codes.Each \nimage frame shall end with a Frame End (FE) Packet containing the Frame End Code.For\nFS and FE synchronization packets the Short Packet Data Field shall contain a 16-bit\nframe number.This frame number shall be the same for the FS and FE synchronization \npackets corresponding to a given frame\nEach image frame shall begin with a Frame Start (FS) Packet containing the Frame \nStart Code.\nEach image frame shall begin with a Frame Start (FS) Packet containing the Frame \nStart Code.\nThe FS Packet shall be followed by one or more long packets containing image data \nand zero or more short packets containing synchronization codes.\nThe FS Packet shall be followed by one or more long packets containing image data \nand zero or more short packets containing synchronization codes.\nEach image frame shall end with a Frame End (FE) Packet containing the Frame End \nCode.\nEach image frame shall end with a Frame End (FE) Packet containing the Frame End \nCode.\nFor FS and FE synchronization packets the Short Packet Data Field shall contain a \n16-bit frame number.\nFor FS and FE synchronization packets the Short Packet Data Field shall contain a \n16-bit frame number.\nThis frame number shall be the same for the FS and FE synchronization packets \ncorresponding to a given frame\nThis frame number shall be the same for the FS and FE synchronization packets \ncorresponding to a given frame", "type": "Document"}}