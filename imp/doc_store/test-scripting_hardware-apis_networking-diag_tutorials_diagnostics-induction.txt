{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "test-scripting_hardware-apis_networking-diag_tutorials_diagnostics-induction.txt"}, "page_content": "Diagnostics Induction\nDiagnostics\nUDS (Universal Diagnostics Standard)\nMost of the projects use it. I Attached the specs\nDiag Request\nDiag request is sent from tester to ECUFirst Byte is called service ID (SID)If the \nservice has Sub-Function, it will be in the second byteExample:0x10 0x01==> SID = \n0x10 (Diag Session Control) | Subfunction ID: 0x01 (Default session)0x22 0xFF \n0xF0==> SID = 0x22 (Read Data By ID)\nDiag request is sent from tester to ECU\nDiag request is sent from tester to ECU\nFirst Byte is called service ID (SID)\nFirst Byte is called service ID (SID)\nIf the service has Sub-Function, it will be in the second byte\nIf the service has Sub-Function, it will be in the second byte\nExample:0x10 0x01==> SID = 0x10 (Diag Session Control) | Subfunction ID: 0x01 \n(Default session)0x22 0xFF 0xF0==> SID = 0x22 (Read Data By ID)\nExample:\n0x10 0x01==> SID = 0x10 (Diag Session Control) | Subfunction ID: 0x01 (Default \nsession)\n0x10 0x01==> SID = 0x10 (Diag Session Control) | Subfunction ID: 0x01 (Default \nsession)\n0x22 0xFF 0xF0==> SID = 0x22 (Read Data By ID)\n0x22 0xFF 0xF0==> SID = 0x22 (Read Data By ID)\nDiag Response\nPositive ResponseIf the ECU could serve the request, it would reply with positive \nresponse.First Byte = SID + 0x40Ex:Request:0x10 0x01==> Change Session to default \nsessionResponse:0x50 0x01==> Session changed successfullyNegative ResponseIf the ECU\ncould not serve the request, it replies with negative response.First Byte = \n0x7FSecond Byte = SIDThird Byte = NRCNRC has a bottom up priority, the lowest \nmatching NRC is sent, means if service is not supported and the length of the \nrequest is also wrong, still NRC SNS will be sent because 0x11 higher prio than \n0x13Where NRC is negative response code0x11==> Service Not Supported (SNS)0x12==> \nSubfunction Not Supported (SFNS)0x13==> Length not correct0x21==> \nbusyRepeatRequest:ECU busy with previously received request, new request is \ndeclinedTester needs to repeat the request after a certain wait timecan be provoked \nby calling a service which is affected by an ECU operation, like creating a DTC and \ntry to read the DTC during the debounce time0x22==> Conditions Not CorrectEx: In \nsecurity Access, tester shall request seed, then send key, if he tries to send key \nwithout requesting seed, he gets this response code0x24==> requestSequenceError, \nwhen defined sequence is not kept, like sendKey sent before requestSeed0x31==> \nRequest Out of Range (ROOR)Trying to read data by ID for not supported IDEx:Req: \n0x22 0xFF 0xFF,Resp: 0x7F 0x22 0x21   , ID 0xFFFF is not supported0x33==> \nsecurityAccessDenied, when ECU needs to be unlocked by security access to call the \nservice, but is locked0x35==> invalidKey, when wrong key is sent after receiving the\nseed0x36==> exceedNumberOfAttempts, when wrong key is sent for several times (number\ndepends on ECU security implementation, for instance 3 times) and new seed is \nrequested0x37==> requiredTimeDelayNotExpired, when maximum number of security access\nwrong attempts is reached, new valid seed will be sent after this delay is expired \n(with powered ECU), for instance 10min0x70==> uploadDownloadNotAccepted, when \nread/write from memory address is not allowed, for instance if memory format or \naddress is wrong0x71==> transferDataSuspended, when a data transfer to memory was \nhalted due to any fault0x72==> generalProgrammingFailure, when erasing or \nprogramming of the ECU memory a failure was detected by the ECU itself0x73==> \nwrongBlockSequenceCounter, when data block transfered to ECU memory has a wrong \nsequence counter, not that an equal to previous counter value is allowed0x78==> \nRequest Pending please wait for responseThe ECU is processing the request, the \ntester shall wait till the ECU sends the request0x7F==> \nserviceNotSupportedInActiveSession, when a service called in a diagnostic session \nwhere it's not support, but in other session(s) (otherwise it's 0x11)0x92==> \nVoltageTooLow0x93==> VoltageTooHighEx:0x22 0xF0 0xFF==> Read data By ID \"0xF0FF\"0x7F\n0x22 0x31==> Request out of range (ID 0xF0FF is not supported)\nPositive ResponseIf the ECU could serve the request, it would reply with positive \nresponse.First Byte = SID + 0x40Ex:Request:0x10 0x01==> Change Session to default \nsessionResponse:0x50 0x01==> Session changed successfully\nPositive Response\nIf the ECU could serve the request, it would reply with positive response.\nIf the ECU could serve the request, it would reply with positive response.\nFirst Byte = SID + 0x40\nFirst Byte = SID + 0x40\nEx:Request:0x10 0x01==> Change Session to default sessionResponse:0x50 0x01==> \nSession changed successfully\nEx:\nRequest:0x10 0x01==> Change Session to default session\nRequest:0x10 0x01==> Change Session to default session\nResponse:0x50 0x01==> Session changed successfully\nResponse:0x50 0x01==> Session changed successfully\nNegative ResponseIf the ECU could not serve the request, it replies with negative \nresponse.First Byte = 0x7FSecond Byte = SIDThird Byte = NRCNRC has a bottom up \npriority, the lowest matching NRC is sent, means if service is not supported and the\nlength of the request is also wrong, still NRC SNS will be sent because 0x11 higher \nprio than 0x13Where NRC is negative response code0x11==> Service Not Supported \n(SNS)0x12==> Subfunction Not Supported (SFNS)0x13==> Length not correct0x21==> \nbusyRepeatRequest:ECU busy with previously received request, new request is \ndeclinedTester needs to repeat the request after a certain wait timecan be provoked \nby calling a service which is affected by an ECU operation, like creating a DTC and \ntry to read the DTC during the debounce time0x22==> Conditions Not CorrectEx: In \nsecurity Access, tester shall request seed, then send key, if he tries to send key \nwithout requesting seed, he gets this response code0x24==> requestSequenceError, \nwhen defined sequence is not kept, like sendKey sent before requestSeed0x31==> \nRequest Out of Range (ROOR)Trying to read data by ID for not supported IDEx:Req: \n0x22 0xFF 0xFF,Resp: 0x7F 0x22 0x21   , ID 0xFFFF is not supported0x33==> \nsecurityAccessDenied, when ECU needs to be unlocked by security access to call the \nservice, but is locked0x35==> invalidKey, when wrong key is sent after receiving the\nseed0x36==> exceedNumberOfAttempts, when wrong key is sent for several times (number\ndepends on ECU security implementation, for instance 3 times) and new seed is \nrequested0x37==> requiredTimeDelayNotExpired, when maximum number of security access\nwrong attempts is reached, new valid seed will be sent after this delay is expired \n(with powered ECU), for instance 10min0x70==> uploadDownloadNotAccepted, when \nread/write from memory address is not allowed, for instance if memory format or \naddress is wrong0x71==> transferDataSuspended, when a data transfer to memory was \nhalted due to any fault0x72==> generalProgrammingFailure, when erasing or \nprogramming of the ECU memory a failure was detected by the ECU itself0x73==> \nwrongBlockSequenceCounter, when data block transfered to ECU memory has a wrong \nsequence counter, not that an equal to previous counter value is allowed0x78==> \nRequest Pending please wait for responseThe ECU is processing the request, the \ntester shall wait till the ECU sends the request0x7F==> \nserviceNotSupportedInActiveSession, when a service called in a diagnostic session \nwhere it's not support, but in other session(s) (otherwise it's 0x11)0x92==> \nVoltageTooLow0x93==> VoltageTooHighEx:0x22 0xF0 0xFF==> Read data By ID \"0xF0FF\"0x7F\n0x22 0x31==> Request out of range (ID 0xF0FF is not supported)\nNegative Response\nIf the ECU could not serve the request, it replies with negative response.\nIf the ECU could not serve the request, it replies with negative response.\nFirst Byte = 0x7F\nFirst Byte = 0x7F\nSecond Byte = SID\nSecond Byte = SID\nThird Byte = NRC\nThird Byte = NRC\nNRC has a bottom up priority, the lowest matching NRC is sent, means if service is \nnot supported and the length of the request is also wrong, still NRC SNS will be \nsent because 0x11 higher prio than 0x13Where NRC is negative response code0x11==> \nService Not Supported (SNS)0x12==> Subfunction Not Supported (SFNS)0x13==> Length \nnot correct0x21==> busyRepeatRequest:ECU busy with previously received request, new \nrequest is declinedTester needs to repeat the request after a certain wait timecan \nbe provoked by calling a service which is affected by an ECU operation, like \ncreating a DTC and try to read the DTC during the debounce time0x22==> Conditions \nNot CorrectEx: In security Access, tester shall request seed, then send key, if he \ntries to send key without requesting seed, he gets this response code0x24==> \nrequestSequenceError, when defined sequence is not kept, like sendKey sent before \nrequestSeed0x31==> Request Out of Range (ROOR)Trying to read data by ID for not \nsupported IDEx:Req: 0x22 0xFF 0xFF,Resp: 0x7F 0x22 0x21   , ID 0xFFFF is not \nsupported0x33==> securityAccessDenied, when ECU needs to be unlocked by security \naccess to call the service, but is locked0x35==> invalidKey, when wrong key is sent \nafter receiving the seed0x36==> exceedNumberOfAttempts, when wrong key is sent for \nseveral times (number depends on ECU security implementation, for instance 3 times) \nand new seed is requested0x37==> requiredTimeDelayNotExpired, when maximum number of\nsecurity access wrong attempts is reached, new valid seed will be sent after this \ndelay is expired (with powered ECU), for instance 10min0x70==> \nuploadDownloadNotAccepted, when read/write from memory address is not allowed, for \ninstance if memory format or address is wrong0x71==> transferDataSuspended, when a \ndata transfer to memory was halted due to any fault0x72==> \ngeneralProgrammingFailure, when erasing or programming of the ECU memory a failure \nwas detected by the ECU itself0x73==> wrongBlockSequenceCounter, when data block \ntransfered to ECU memory has a wrong sequence counter, not that an equal to previous\ncounter value is allowed0x78==> Request Pending please wait for responseThe ECU is \nprocessing the request, the tester shall wait till the ECU sends the request0x7F==> \nserviceNotSupportedInActiveSession, when a service called in a diagnostic session \nwhere it's not support, but in other session(s) (otherwise it's 0x11)0x92==> \nVoltageTooLow0x93==> VoltageTooHigh\nNRC has a bottom up priority, the lowest matching NRC is sent, means if service is \nnot supported and the length of the request is also wrong, still NRC SNS will be \nsent because 0x11 higher prio than 0x13\nWhere NRC is negative response code\nWhere NRC is negative response code\n0x11==> Service Not Supported (SNS)\n0x11==> Service Not Supported (SNS)\n0x12==> Subfunction Not Supported (SFNS)\n0x12==> Subfunction Not Supported (SFNS)\n0x13==> Length not correct\n0x13==> Length not correct\n0x21==> busyRepeatRequest:ECU busy with previously received request, new request is \ndeclinedTester needs to repeat the request after a certain wait timecan be provoked \nby calling a service which is affected by an ECU operation, like creating a DTC and \ntry to read the DTC during the debounce time\n0x21==> busyRepeatRequest:\nECU busy with previously received request, new request is declined\nECU busy with previously received request, new request is declined\nTester needs to repeat the request after a certain wait time\nTester needs to repeat the request after a certain wait time\ncan be provoked by calling a service which is affected by an ECU operation, like \ncreating a DTC and try to read the DTC during the debounce time\ncan be provoked by calling a service which is affected by an ECU operation, like \ncreating a DTC and try to read the DTC during the debounce time\n0x22==> Conditions Not CorrectEx: In security Access, tester shall request seed, \nthen send key, if he tries to send key without requesting seed, he gets this \nresponse code\n0x22==> Conditions Not Correct\nEx: In security Access, tester shall request seed, then send key, if he tries to \nsend key without requesting seed, he gets this response code\nEx: In security Access, tester shall request seed, then send key, if he tries to \nsend key without requesting seed, he gets this response code\n0x24==> requestSequenceError, when defined sequence is not kept, like sendKey sent \nbefore requestSeed\n0x24==> requestSequenceError, when defined sequence is not kept, like sendKey sent \nbefore requestSeed\n0x31==> Request Out of Range (ROOR)Trying to read data by ID for not supported \nIDEx:Req: 0x22 0xFF 0xFF,Resp: 0x7F 0x22 0x21   , ID 0xFFFF is not supported\n0x31==> Request Out of Range (ROOR)\nTrying to read data by ID for not supported ID\nTrying to read data by ID for not supported ID\nEx:Req: 0x22 0xFF 0xFF,Resp: 0x7F 0x22 0x21   , ID 0xFFFF is not supported\nEx:\nReq: 0x22 0xFF 0xFF,\nReq: 0x22 0xFF 0xFF,\nResp: 0x7F 0x22 0x21   , ID 0xFFFF is not supported\nResp: 0x7F 0x22 0x21   , ID 0xFFFF is not supported\n0x33==> securityAccessDenied, when ECU needs to be unlocked by security access to \ncall the service, but is locked\n0x33==> securityAccessDenied, when ECU needs to be unlocked by security access to \ncall the service, but is locked\n0x35==> invalidKey, when wrong key is sent after receiving the seed\n0x35==> invalidKey, when wrong key is sent after receiving the seed\n0x36==> exceedNumberOfAttempts, when wrong key is sent for several times (number \ndepends on ECU security implementation, for instance 3 times) and new seed is \nrequested\n0x36==> exceedNumberOfAttempts, when wrong key is sent for several times (number \ndepends on ECU security implementation, for instance 3 times) and new seed is \nrequested\n0x37==> requiredTimeDelayNotExpired, when maximum number of security access wrong \nattempts is reached, new valid seed will be sent after this delay is expired (with \npowered ECU), for instance 10min\n0x37==> requiredTimeDelayNotExpired, when maximum number of security access wrong \nattempts is reached, new valid seed will be sent after this delay is expired (with \npowered ECU), for instance 10min\n0x70==> uploadDownloadNotAccepted, when read/write from memory address is not \nallowed, for instance if memory format or address is wrong\n0x70==> uploadDownloadNotAccepted, when read/write from memory address is not \nallowed, for instance if memory format or address is wrong\n0x71==> transferDataSuspended, when a data transfer to memory was halted due to any \nfault\n0x71==> transferDataSuspended, when a data transfer to memory was halted due to any \nfault\n0x72==> generalProgrammingFailure, when erasing or programming of the ECU memory a \nfailure was detected by the ECU itself\n0x72==> generalProgrammingFailure, when erasing or programming of the ECU memory a \nfailure was detected by the ECU itself\n0x73==> wrongBlockSequenceCounter, when data block transfered to ECU memory has a \nwrong sequence counter, not that an equal to previous counter value is allowed\n0x73==> wrongBlockSequenceCounter, when data block transfered to ECU memory has a \nwrong sequence counter, not that an equal to previous counter value is allowed\n0x78==> Request Pending please wait for responseThe ECU is processing the request, \nthe tester shall wait till the ECU sends the request\n0x78==> Request Pending please wait for response\nThe ECU is processing the request, the tester shall wait till the ECU sends the \nrequest\nThe ECU is processing the request, the tester shall wait till the ECU sends the \nrequest\n0x7F==> serviceNotSupportedInActiveSession, when a service called in a diagnostic \nsession where it's not support, but in other session(s) (otherwise it's 0x11)\n0x7F==> serviceNotSupportedInActiveSession, when a service called in a diagnostic \nsession where it's not support, but in other session(s) (otherwise it's 0x11)\n0x92==> VoltageTooLow\n0x92==> VoltageTooLow\n0x93==> VoltageTooHigh\n0x93==> VoltageTooHigh\nEx:0x22 0xF0 0xFF==> Read data By ID \"0xF0FF\"0x7F 0x22 0x31==> Request out of range \n(ID 0xF0FF is not supported)\nEx:\n0x22 0xF0 0xFF==> Read data By ID \"0xF0FF\"\n0x22 0xF0 0xFF==> Read data By ID \"0xF0FF\"\n0x7F 0x22 0x31==> Request out of range (ID 0xF0FF is not supported)\n0x7F 0x22 0x31==> Request out of range (ID 0xF0FF is not supported)\nSuppress Positive Response Bit\nMSB in the subfunction byte, is the suppress positive response.If Suppress Positive \nresponse bit is equal to one, then the ECU shall respond only if the response is a \nnegative responseEx:Req:0x10 0x81\nMSB in the subfunction byte, is the suppress positive response.\nMSB in the subfunction byte, is the suppress positive response.\nIf Suppress Positive response bit is equal to one, then the ECU shall respond only \nif the response is a negative response\nIf Suppress Positive response bit is equal to one, then the ECU shall respond only \nif the response is a negative response\nEx:Req:0x10 0x81\nEx:\nReq:0x10 0x81\nReq:0x10 0x81\nPhysical Request\nThe physical request is sent to a specific ECU\nThe physical request is sent to a specific ECU\nThe physical request is sent to a specific ECU\nFunctional Request\nThe functional request is sent to all ECUs (some kind of broadcasting)In this case, \nECUs only reply if the following conditions are satisfiedThe response is not \npositive responseThe response is not negative response with response \ncode0x11(Service Not Supported SNS)The response is not negative response with \nresponse code0x12(SubFunction Not Supported SFNS)The response is not negative \nresponse with response code0x31(Request out of Range ROOR)In case the functional \nrequest is long (will be divided upon multiple frames), the ECU shall neglect it.\nThe functional request is sent to all ECUs (some kind of broadcasting)\nThe functional request is sent to all ECUs (some kind of broadcasting)\nIn this case, ECUs only reply if the following conditions are satisfiedThe response \nis not positive responseThe response is not negative response with response \ncode0x11(Service Not Supported SNS)The response is not negative response with \nresponse code0x12(SubFunction Not Supported SFNS)The response is not negative \nresponse with response code0x31(Request out of Range ROOR)\nIn this case, ECUs only reply if the following conditions are satisfied\nThe response is not positive response\nThe response is not positive response\nThe response is not negative response with response code0x11(Service Not Supported \nSNS)\nThe response is not negative response with response code0x11(Service Not Supported \nSNS)\nThe response is not negative response with response code0x12(SubFunction Not \nSupported SFNS)\nThe response is not negative response with response code0x12(SubFunction Not \nSupported SFNS)\nThe response is not negative response with response code0x31(Request out of Range \nROOR)\nThe response is not negative response with response code0x31(Request out of Range \nROOR)\nIn case the functional request is long (will be divided upon multiple frames), the \nECU shall neglect it.\nIn case the functional request is long (will be divided upon multiple frames), the \nECU shall neglect it.\nDiag Session Control (0x10)\nRequest0x10 0xXXChange non-default session has a timeout, after elapsing without \nreceiving another diagRequest (at leat TesterPresent) the ECU will return to \nDefaultSessiontimeout sent in positive response sessionParameterRecord (byte no. 3 \nto n)Change active session to session XXXX =0x01==> Default sessionXX =0x02==> \nProgramming Session (Bootloader)Some diag services are not supported in default \nsession, they require to switch to Programming session to request them.XX =0x03==> \nExtended SessionSome diag services are not supported in default session, they \nrequire to switch to extended session to request them.\nRequest0x10 0xXX\nRequest0x10 0xXX\nChange non-default session has a timeout, after elapsing without receiving another \ndiagRequest (at leat TesterPresent) the ECU will return to DefaultSession\nChange non-default session has a timeout, after elapsing without receiving another \ndiagRequest (at leat TesterPresent) the ECU will return to DefaultSession\ntimeout sent in positive response sessionParameterRecord (byte no. 3 to n)\ntimeout sent in positive response sessionParameterRecord (byte no. 3 to n)\nChange active session to session XXXX =0x01==> Default sessionXX =0x02==> \nProgramming Session (Bootloader)Some diag services are not supported in default \nsession, they require to switch to Programming session to request them.XX =0x03==> \nExtended SessionSome diag services are not supported in default session, they \nrequire to switch to extended session to request them.\nChange active session to session XX\nXX =0x01==> Default session\nXX =0x01==> Default session\nXX =0x02==> Programming Session (Bootloader)Some diag services are not supported in \ndefault session, they require to switch to Programming session to request them.\nXX =0x02==> Programming Session (Bootloader)\nSome diag services are not supported in default session, they require to switch to \nProgramming session to request them.\nSome diag services are not supported in default session, they require to switch to \nProgramming session to request them.\nXX =0x03==> Extended SessionSome diag services are not supported in default session,\nthey require to switch to extended session to request them.\nXX =0x03==> Extended Session\nSome diag services are not supported in default session, they require to switch to \nextended session to request them.\nSome diag services are not supported in default session, they require to switch to \nextended session to request them.\nTable of services to be supported in defaultSession and non-defaultSession (which \ndepends on Implementation)\nECU Reset (0x11)\nRequest:0x11 0xXXXX is the reset type:0x01==> Hard reset (Power On reset)0x03==> \nSoft reset (Application Reset)\nRequest:0x11 0xXX\nRequest:0x11 0xXX\nXX is the reset type:0x01==> Hard reset (Power On reset)0x03==> Soft reset \n(Application Reset)\nXX is the reset type:\n0x01==> Hard reset (Power On reset)\n0x01==> Hard reset (Power On reset)\n0x03==> Soft reset (Application Reset)\n0x03==> Soft reset (Application Reset)\nSecurity Access (0x27)\nSome diag services requires security privilege to be supportedSteps:Req:0x27 0x01==>\nRequest Seed for security level 0x01Resp:0x67 0x01 XX XX XX XX==> where XX XX XX XX \nis the seedReq:0x27 0x02 YY YY YY YY==> The testing tool receives the seed, gets the\nkey through passing the seed into security algorithmResp:0x67 0x02==> The ECU \nconfirms that the Key is correct, and opens the security level requested \n(0x01).Normally, the algorithm of calculating the key is done inside the firmware. \nHere are the sequence inside the test script (Pseudo-code)Diag().afcSend(\"27 \n01\");WaitUntilEvent(evtDiagResp);Diag().afcPrepare(\"27 02 FF FF FF \nFF\");Diag().afcCalcAccessKey();Diag().afcSendPrepared();There may be multiple \nalgorithms for multiple security levels.\nSome diag services requires security privilege to be supported\nSome diag services requires security privilege to be supported\nSteps:Req:0x27 0x01==> Request Seed for security level 0x01Resp:0x67 0x01 XX XX XX \nXX==> where XX XX XX XX is the seedReq:0x27 0x02 YY YY YY YY==> The testing tool \nreceives the seed, gets the key through passing the seed into security \nalgorithmResp:0x67 0x02==> The ECU confirms that the Key is correct, and opens the \nsecurity level requested (0x01).\nSteps:\nReq:0x27 0x01==> Request Seed for security level 0x01\nReq:0x27 0x01==> Request Seed for security level 0x01\nResp:0x67 0x01 XX XX XX XX==> where XX XX XX XX is the seed\nResp:0x67 0x01 XX XX XX XX==> where XX XX XX XX is the seed\nReq:0x27 0x02 YY YY YY YY==> The testing tool receives the seed, gets the key \nthrough passing the seed into security algorithm\nReq:0x27 0x02 YY YY YY YY==> The testing tool receives the seed, gets the key \nthrough passing the seed into security algorithm\nResp:0x67 0x02==> The ECU confirms that the Key is correct, and opens the security \nlevel requested (0x01).\nResp:0x67 0x02==> The ECU confirms that the Key is correct, and opens the security \nlevel requested (0x01).\nNormally, the algorithm of calculating the key is done inside the firmware. Here are\nthe sequence inside the test script (Pseudo-code)\nNormally, the algorithm of calculating the key is done inside the firmware. Here are\nthe sequence inside the test script (Pseudo-code)\nDiag().afcSend(\"27 01\");\nDiag().afcSend(\"27 01\");\nWaitUntilEvent(evtDiagResp);\nWaitUntilEvent(evtDiagResp);\nDiag().afcPrepare(\"27 02 FF FF FF FF\");\nDiag().afcPrepare(\"27 02 FF FF FF FF\");\nDiag().afcCalcAccessKey();\nDiag().afcCalcAccessKey();\nDiag().afcSendPrepared();\nDiag().afcSendPrepared();\nThere may be multiple algorithms for multiple security levels.\nThere may be multiple algorithms for multiple security levels.\nTester Present (0x3E)\nRequest:0x3E 0x00Is used to tell the ECU that the client (the tester) is still \nconnected.Example:Request:0x10 0x03==> Request Extended sessionResp:0x50==> Extended\nsession activeNormally it will be active for 5 seconds, then goes to default session\nagain if the client did not send anythingRequest:0x3E 0x00The client is still \nconnected, hence the ECU will reset the 5 seconds timerResponse:0x7E\nRequest:0x3E 0x00\nRequest:0x3E 0x00\nIs used to tell the ECU that the client (the tester) is still connected.\nIs used to tell the ECU that the client (the tester) is still connected.\nExample:Request:0x10 0x03==> Request Extended sessionResp:0x50==> Extended session \nactiveNormally it will be active for 5 seconds, then goes to default session again \nif the client did not send anythingRequest:0x3E 0x00The client is still connected, \nhence the ECU will reset the 5 seconds timerResponse:0x7E\nExample:\nRequest:0x10 0x03==> Request Extended session\nRequest:0x10 0x03==> Request Extended session\nResp:0x50==> Extended session activeNormally it will be active for 5 seconds, then \ngoes to default session again if the client did not send anything\nResp:0x50==> Extended session active\nNormally it will be active for 5 seconds, then goes to default session again if the \nclient did not send anything\nNormally it will be active for 5 seconds, then goes to default session again if the \nclient did not send anything\nRequest:0x3E 0x00The client is still connected, hence the ECU will reset the 5 \nseconds timer\nRequest:0x3E 0x00\nThe client is still connected, hence the ECU will reset the 5 seconds timer\nThe client is still connected, hence the ECU will reset the 5 seconds timer\nResponse:0x7E\nResponse:0x7E\nDTC\nDTC is Diagnostic Trouble CodeAny failure happens in the system, is saved into the \nDTC memory, through a unique code called \"DTC\", and some info is stored in this \nrecord such as:Failure State? (Active - Fixed - ..etc)Time of creation....There is \nsome diag services to make the followingClear DTC Memory (0x14 0xFF 0xFF 0xFF), also\ngroup of DTC are possible if supportedClear SingleDTC (0x14 0xAA 0xBB 0xCC), where \nAA BB CC is the DTC to clear, all other DTCs will keep storedRead The DTCs of a \nspecific state (For example read all active DTCs)Read the data record of a specific \nDTCRead the number of DTCs...\nDTC is Diagnostic Trouble Code\nDTC is Diagnostic Trouble Code\nAny failure happens in the system, is saved into the DTC memory, through a unique \ncode called \"DTC\", and some info is stored in this record such as:Failure State? \n(Active - Fixed - ..etc)Time of creation....\nAny failure happens in the system, is saved into the DTC memory, through a unique \ncode called \"DTC\", and some info is stored in this record such as:\nFailure State? (Active - Fixed - ..etc)\nFailure State? (Active - Fixed - ..etc)\nTime of creation\nTime of creation\n....\n....\nThere is some diag services to make the followingClear DTC Memory (0x14 0xFF 0xFF \n0xFF), also group of DTC are possible if supportedClear SingleDTC (0x14 0xAA 0xBB \n0xCC), where AA BB CC is the DTC to clear, all other DTCs will keep storedRead The \nDTCs of a specific state (For example read all active DTCs)Read the data record of a\nspecific DTCRead the number of DTCs...\nThere is some diag services to make the following\nClear DTC Memory (0x14 0xFF 0xFF 0xFF), also group of DTC are possible if supported\nClear DTC Memory (0x14 0xFF 0xFF 0xFF), also group of DTC are possible if supported\nClear SingleDTC (0x14 0xAA 0xBB 0xCC), where AA BB CC is the DTC to clear, all other\nDTCs will keep stored\nClear SingleDTC (0x14 0xAA 0xBB 0xCC), where AA BB CC is the DTC to clear, all other\nDTCs will keep stored\nRead The DTCs of a specific state (For example read all active DTCs)\nRead The DTCs of a specific state (For example read all active DTCs)\nRead the data record of a specific DTC\nRead the data record of a specific DTC\nRead the number of DTCs\nRead the number of DTCs\n...\n...\nRead Data By ID (0x22)\nRead the data in the ID specifiedEx:Req:0x22 0xFF 0x0FResp:0x62 0xFF 0x0F XX XX XX \nXX XX(where XX XX XX XX is the data in the ID 0xFF0F)\nRead the data in the ID specified\nRead the data in the ID specified\nEx:Req:0x22 0xFF 0x0FResp:0x62 0xFF 0x0F XX XX XX XX XX(where XX XX XX XX is the \ndata in the ID 0xFF0F)\nEx:\nReq:0x22 0xFF 0x0F\nReq:0x22 0xFF 0x0F\nResp:0x62 0xFF 0x0F XX XX XX XX XX(where XX XX XX XX is the data in the ID 0xFF0F)\nResp:0x62 0xFF 0x0F XX XX XX XX XX(where XX XX XX XX is the data in the ID 0xFF0F)\nWrite Data By ID (0x2E)\nWrite the data in the specified IDEx:Req:0x2E 0xFF 0x0F XX XX XX XX XX(write the \ndata \"XX XX XX XX XX\" in the ID \"0xFF 0x0F\")Resp:0x6E 0xFF 0x0F\nWrite the data in the specified ID\nWrite the data in the specified ID\nEx:Req:0x2E 0xFF 0x0F XX XX XX XX XX(write the data \"XX XX XX XX XX\" in the ID \"0xFF\n0x0F\")Resp:0x6E 0xFF 0x0F\nEx:\nReq:0x2E 0xFF 0x0F XX XX XX XX XX(write the data \"XX XX XX XX XX\" in the ID \"0xFF \n0x0F\")\nReq:0x2E 0xFF 0x0F XX XX XX XX XX(write the data \"XX XX XX XX XX\" in the ID \"0xFF \n0x0F\")\nResp:0x6E 0xFF 0x0F\nResp:0x6E 0xFF 0x0F\nKWP\nAnother Specs for diag. Used in old projects.\nTP Layer\nI attached two different tp layer standards, Autosar for FR and ISO for FR\nAutosar For FR\nAs an example, we will go through Autosar Tp Layer For Diagnostics.\nIf the diag request/response is bigger than the containing PDU/Frame, this means it \nwill be divided to separate frames.\nExample 1\nSingle Frame Request:0x10 0x01==> after TP ==>0x02 0x10 0x01\nHere is the breakdown:\nFirst ByteFirst 4 Bits: 0x0 ==>Single FrameSecond 4 Bits: 0x2 ==>Lengthis 2 bytes\nFirst Byte\nFirst 4 Bits: 0x0 ==>Single FrameSecond 4 Bits: 0x2 ==>Lengthis 2 bytes\nFirst 4 Bits: 0x0 ==>Single Frame\nFirst 4 Bits: 0x0 ==>Single Frame\nSecond 4 Bits: 0x2 ==>Lengthis 2 bytes\nSecond 4 Bits: 0x2 ==>Lengthis 2 bytes\nOther Bytes0x10 0x01 ==> the request\nOther Bytes\n0x10 0x01 ==> the request\n0x10 0x01 ==> the request\n0x10 0x01 ==> the request\nExample 2\nMultiFrame Request:0x2E 0xFF 0x0F 0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88 0x99 0x00 \n0x01\nAssume the frame is 8 bytes\nSender:0x10 0x0E 0x2E 0xFF 0x0F 0x11 0x22 0x33First two Byte:First 4 bits: 0x1 \n:First FrameFollowing 12 bits: 0x00E:Lengthis 14 bytesReceiver:0x30 0xBB 0xSSFirst \nByte:0x30: (Flow Control) the receiver is ready to receiveSecond Byte0xBB: Block \nsize, means that the sender shall send the rest of the request in blocks, each block\nis of 0xBB bytes. After the block is sent, wait for another flow control from the \nReceiverThird Byte0xSS: The sender shall send the consecutive frames separated by \n0xSSSender:0x21 0x44 0x55 0x66 0x77 0x88 0x99 0x00First Byte:0x21First Consecutive \nFramesFirst 4 Bits: 0x2 :Consecutive frameSecond 4 Bits: 0x1:Sequence Number= \n1Sender:0x22 0x01First Byte:0x22First Consecutive FramesFirst 4 Bits: 0x2 \n:Consecutive frameSecond 4 Bits: 0x2:Sequence Number= 2\nSender:0x10 0x0E 0x2E 0xFF 0x0F 0x11 0x22 0x33First two Byte:First 4 bits: 0x1 \n:First FrameFollowing 12 bits: 0x00E:Lengthis 14 bytes\nSender:0x10 0x0E 0x2E 0xFF 0x0F 0x11 0x22 0x33\nFirst two Byte:First 4 bits: 0x1 :First FrameFollowing 12 bits: 0x00E:Lengthis 14 \nbytes\nFirst two Byte:\nFirst 4 bits: 0x1 :First Frame\nFirst 4 bits: 0x1 :First Frame\nFollowing 12 bits: 0x00E:Lengthis 14 bytes\nFollowing 12 bits: 0x00E:Lengthis 14 bytes\nReceiver:0x30 0xBB 0xSSFirst Byte:0x30: (Flow Control) the receiver is ready to \nreceiveSecond Byte0xBB: Block size, means that the sender shall send the rest of the\nrequest in blocks, each block is of 0xBB bytes. After the block is sent, wait for \nanother flow control from the ReceiverThird Byte0xSS: The sender shall send the \nconsecutive frames separated by 0xSS\nReceiver:0x30 0xBB 0xSS\nFirst Byte:0x30: (Flow Control) the receiver is ready to receive\nFirst Byte:\n0x30: (Flow Control) the receiver is ready to receive\n0x30: (Flow Control) the receiver is ready to receive\nSecond Byte0xBB: Block size, means that the sender shall send the rest of the \nrequest in blocks, each block is of 0xBB bytes. After the block is sent, wait for \nanother flow control from the Receiver\nSecond Byte\n0xBB: Block size, means that the sender shall send the rest of the request in \nblocks, each block is of 0xBB bytes. After the block is sent, wait for another flow \ncontrol from the Receiver\n0xBB: Block size, means that the sender shall send the rest of the request in \nblocks, each block is of 0xBB bytes. After the block is sent, wait for another flow \ncontrol from the Receiver\nThird Byte0xSS: The sender shall send the consecutive frames separated by 0xSS\nThird Byte\n0xSS: The sender shall send the consecutive frames separated by 0xSS\n0xSS: The sender shall send the consecutive frames separated by 0xSS\nSender:0x21 0x44 0x55 0x66 0x77 0x88 0x99 0x00First Byte:0x21First Consecutive \nFramesFirst 4 Bits: 0x2 :Consecutive frameSecond 4 Bits: 0x1:Sequence Number= 1\nSender:0x21 0x44 0x55 0x66 0x77 0x88 0x99 0x00\nFirst Byte:0x21First Consecutive FramesFirst 4 Bits: 0x2 :Consecutive frameSecond 4 \nBits: 0x1:Sequence Number= 1\nFirst Byte:\n0x21First Consecutive FramesFirst 4 Bits: 0x2 :Consecutive frameSecond 4 Bits: \n0x1:Sequence Number= 1\n0x21\nFirst Consecutive Frames\nFirst Consecutive Frames\nFirst 4 Bits: 0x2 :Consecutive frame\nFirst 4 Bits: 0x2 :Consecutive frame\nSecond 4 Bits: 0x1:Sequence Number= 1\nSecond 4 Bits: 0x1:Sequence Number= 1\nSender:0x22 0x01First Byte:0x22First Consecutive FramesFirst 4 Bits: 0x2 \n:Consecutive frameSecond 4 Bits: 0x2:Sequence Number= 2\nSender:0x22 0x01\nFirst Byte:0x22First Consecutive FramesFirst 4 Bits: 0x2 :Consecutive frameSecond 4 \nBits: 0x2:Sequence Number= 2\nFirst Byte:\n0x22First Consecutive FramesFirst 4 Bits: 0x2 :Consecutive frameSecond 4 Bits: \n0x2:Sequence Number= 2\n0x22\nFirst Consecutive Frames\nFirst Consecutive Frames\nFirst 4 Bits: 0x2 :Consecutive frame\nFirst 4 Bits: 0x2 :Consecutive frame\nSecond 4 Bits: 0x2:Sequence Number= 2\nSecond 4 Bits: 0x2:Sequence Number= 2\nCASTLE Firmware Functions\nThe most common functions:\nDiag().afcSend(\"XX XX\");   // send diag request XX XX on the bus\nDiag().afcSend(\"XX XX\");   // send diag request XX XX on the bus\nDiag().afcPrepare(\"XX XX\"); // Adds the bytes XX XX to the diag req buffer, do not \nsend anything on the bus\nDiag().afcPrepare(\"XX XX\"); // Adds the bytes XX XX to the diag req buffer, do not \nsend anything on the bus\nDiag().afcModifyPrepare(); // Modify certain part in the diag req buffer\nDiag().afcModifyPrepare(); // Modify certain part in the diag req buffer\nDiag().afcSendPrepared();    // Send the prepared diag req buffer on the bus\nDiag().afcSendPrepared();    // Send the prepared diag req buffer on the bus\nDiag().afcTestByteSequence(); // Test the diag response captured from the ECU\nDiag().afcTestByteSequence(); // Test the diag response captured from the ECU\nDiag().afcCalculateAccessKey();  // Calculate Key from Seed, this shall be called \nafter requesting seed as mentioned in the Security Access section above.\nDiag().afcCalculateAccessKey();  // Calculate Key from Seed, this shall be called \nafter requesting seed as mentioned in the Security Access section above.\nDiag().afcConfigureNextSend_Response(SuppressPosResp, SuppressNegResp, \nAllowPending);// Normally, when CASTLE sends a request, it expects a response \nwithing timeout (default 1 second), you can instruct CASTLE that it shall only \nreceive pos or neg response, or not receive both via the the 1st and 2nd arguments \nof this function.// The 3rd Argument, instruct CASTLE to skip response pending \nnegResp (0x7F 0xXX 0x78) and wait for the next response from ECU.\nDiag().afcConfigureNextSend_Response(SuppressPosResp, SuppressNegResp, \nAllowPending);\n// Normally, when CASTLE sends a request, it expects a response withing timeout \n(default 1 second), you can instruct CASTLE that it shall only receive pos or neg \nresponse, or not receive both via the the 1st and 2nd arguments of this function.\n// Normally, when CASTLE sends a request, it expects a response withing timeout \n(default 1 second), you can instruct CASTLE that it shall only receive pos or neg \nresponse, or not receive both via the the 1st and 2nd arguments of this function.\n// The 3rd Argument, instruct CASTLE to skip response pending negResp (0x7F 0xXX \n0x78) and wait for the next response from ECU.\n// The 3rd Argument, instruct CASTLE to skip response pending negResp (0x7F 0xXX \n0x78) and wait for the next response from ECU.\nDiag().afcConfigureTimeOut();  // change timeout for receiving diag response after \nsending a request\nDiag().afcConfigureTimeOut();  // change timeout for receiving diag response after \nsending a request\nSample Test Scenario\nHere is a sample test case from Validation Engineers (I attached the whole Test \nGroup)", "type": "Document"}}