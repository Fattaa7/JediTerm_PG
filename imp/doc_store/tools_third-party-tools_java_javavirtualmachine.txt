{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "tools_third-party-tools_java_javavirtualmachine.txt"}, "page_content": "Java Virtual Machine\nPost date: Mar 6, 2016 12:23:32 PM\nCompile:\nWhen a programmer finishes his Java code and click \"Run\":\n1. Compiler: Java -->Byte code\n2. Java Virtual Machine:Byte Code--> native binary\nNative binary is target specific, i.e: each target has its Native binary op-codes, \nwhich differs from other Target\nEx: X86 Architecture have certain op-codes, Atmel Architecture has different \nop-codes, accordingly the native binary file (which can be defined as: the program \nwritten in terms of Architecture op-code) will be different.\nThe same happens when \".NET\" code is compiled:\n1. Compiler: C#,C++,VB, ...etc. --> Byte code\n2. .NET Machine: Byte Code --> native binary\nDynamic Allocation:\nPart of the functionality of the Java Virtual Machine, is to \"malloc\" objects in the\nheap during run time.\nObject S = new Object(xx);     --> mallocS = new Object(yy);               --> \nmalloc for new object, the garbage collector frees the old one\nObject S = new Object(xx);     --> malloc\nS = new Object(yy);               --> malloc for new object, the garbage collector \nfrees the old one\nS = new Object(yy);               --> malloc for new object, the garbage collector \nfrees the old one\nS = null;                                --> free     (This is done by Grabage \ncollector)\nS = null;                                --> free     (This is done by Grabage \ncollector)\nin .launch file:\n<stringAttribute key=\"org.eclipse.jdt.launching.VM_ARGUMENTS\" \nvalue=\"-Dosgi.requiredJavaVersion=1.5 -Xms40m -Xmx384m\"/>\nIn this line, the size of the heap used by the Java Virtual Machine (to \"malloc\" and\n\"free\" memory for the objects created in run time) is defined\nGarbage Collector:\nThe Garbage Collector is responsible for \"free\" the unused parts in the Heap", "type": "Document"}}