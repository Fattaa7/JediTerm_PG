{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"metadata": {"source": "tools_third-party-tools_java_javaunittesting-asserts.txt"}, "page_content": "Java unit testing - asserts\nPost date: Nov 10, 2016 7:14:42 PM\nIn Java unittesting we use JUnit.\nOne test case should normally have exactly one single assertion to have the clearest\nresult.\nA assert, when failing shall give a good error message, so it can be easily \nunderstood.\nThe assert from JUnit:\nimport org.junit.Assert;\nAssert.assertEquals(\"Pdu1\", trg.getObjectName());\nAssert.assertEquals(\"my details\", \"Pdu1\", trg.getObjectName());\nYou pass the values individually. That means, you do not do the equals call yourself\nand pass true/false. Beause if you pass the values, the assertEquals can create a \nerror message where it prints both values.\nDisadvantage here is, that you can easily give expected/actual in the wrong order, \nwhich leads to confusion in the error message.\nDisadvantage 2, the optional description is given as first param and does not allow \nprintf syntax, so you would need to call String.format on you own if needed.\nThis is why i prefer theorg.assertj framework.\nThe general syntax is like this:\nAssertions.assertThat(actualValue).isEqualTo(expected);\nIf the import is yet missing, i start to type\nThis add the class import. Then i continue to type\nAssertions.assertThat(....)\nWhen the statement is completed, i come back and place the cursor into \"assertThat\" \nand press Ctrl+Shift+M (\"Add import\"), which imports this static symbol.\nimport static org.assertj.core.api.Assertions.assertThat;\nassertThat(....)\nNow you can easily access those function that are available depending on the actual \ntype.\nYou can set a description with .as(), for collections and other types of values \nthere are many different comparison functions.\nE.g. for string there is isEqualsTo, isEqualToIgnoringWhitespaces, \nisEqualsToIngoringCase, ....", "type": "Document"}}